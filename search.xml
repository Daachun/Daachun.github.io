<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Shader]-OldSchool基础着色器</title>
      <link href="2021/03/06/Shader/shader-OldSchool/"/>
      <url>2021/03/06/Shader/shader-OldSchool/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一些命名约定…"><a href="#一些命名约定…" class="headerlink" title="一些命名约定…"></a>一些命名约定…</h1><p>常用向量：</p><ul><li><code>nDir</code>：法线方向</li><li><code>lDir</code>：光方向</li><li><code>vDir</code>：观察方向</li><li><code>rDir/lrDir</code>：光反射方向</li><li><code>hDir</code>：（halfway）lDir和vDir的中间角（半角）方向</li><li><code>vrDir</code>：观察方向的反射方向…</li></ul><p>所在空间：</p><ul><li><code>OS</code>：ObjectSpace 物体空间</li><li><code>WS</code>：WorldSpace 世界空间</li><li><code>VS</code>：ViewSpace 观察空间</li><li><code>CS</code>：homogeneousClipSpace 齐次裁剪空间</li><li><code>TS</code>：TangentSpace 切线空间</li><li><code>TXS</code>：TextureSpace 纹理空间</li></ul><p>例：<code>nDirWS</code>-世界空间法线方向</p><h1 id="OldSchool-Shader"><a href="#OldSchool-Shader" class="headerlink" title="OldSchool Shader"></a>OldSchool Shader</h1><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210306232629.png" alt="image-20210306231559805"></p><p>默认在Forward Rendering Path的基础上。</p><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>对法线贴图(normal mapping)进行采样，需要将存储在纹理空间中的法向量转换到模型空间中，最终转化为世界空间的法线。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VertexOutput vert (VertexInput v) &#123; &#x2F;&#x2F; 顶点Shader</span><br><span class="line">VertexOutput o &#x3D; (VertexOutput)0;</span><br><span class="line">o.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);      &#x2F;&#x2F; 法线方向</span><br><span class="line">o.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz,0.0)).xyz);  &#x2F;&#x2F; 切线方向</span><br><span class="line">o.bDirWS &#x3D; normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w);  &#x2F;&#x2F; 副切线方向</span><br><span class="line">TRANSFER_VERTEX_TO_FRAGMENT(o)                      &#x2F;&#x2F; 投影相关 </span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tDirWS</code>指的是切线方向，``bDirWS`是副切线方向，需要构建TBN矩阵来进行空间转化。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float4 frag(VertexOutput i) : COLOR &#123;   &#x2F;&#x2F; 片元Shader 输出rgba</span><br><span class="line">        &#x2F;&#x2F; 向量准备</span><br><span class="line">float3 nDirTS &#x3D; UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;    &#x2F;&#x2F; 切线空间法线方向</span><br><span class="line">float3x3 TBN &#x3D; float3x3(i.tDirWS, i.bDirWS, i.nDirWS);      &#x2F;&#x2F; TBN矩阵，用于将法线从切线空间转到世界空间</span><br><span class="line">float3 nDirWS &#x3D; normalize(mul(nDirTS, TBN));                &#x2F;&#x2F; 世界空间法线方向</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，<code>VertexOutput</code>中的<code>nDirWS</code>实际上是模型自带法线转为世界空间的方向，通过TBN矩阵将法线贴图中的法线方向转到世界空间。</p><h2 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h2><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>Lambert很简单：法线方向和光方向点乘，取大于零的数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float lambert &#x3D; max(0.0, ndotl);</span><br></pre></td></tr></table></figure><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307004127.gif" alt="Lambert" style="zoom: 50%;" /><p>Half-Lambert在上方基础上，进行了Remap，将[0,1]的计算结果置换到了[0.5,1]之间。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float halflambert &#x3D; max(0.0, ndotl) * 0.5 + 0.5;</span><br></pre></td></tr></table></figure><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307004155.gif" alt="HalfLambert" style="zoom:50%;" /><p>可以看到，半兰伯特更淡一点讨好眼睛。当然其中的0.5值不是固定不变的，可以根据需求修改。</p><p>固有色和贴图，乘上去就行了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float4 var_MainTex &#x3D; tex2D(_MainTex, i.uv0);&#x2F;&#x2F; 纹理采样</span><br><span class="line">float3 baseCol &#x3D; var_MainTex * _MainCol;</span><br><span class="line">&#x2F;&#x2F; 固有色结果为 baseCol * lambert</span><br></pre></td></tr></table></figure><h3 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h3><p>常用Phong光照模型和Blinn-Phong光照模型，都比较简单，只考虑物体对直接光照的反射作用，认为环境光是常量，没有考虑物体之间相互的反射光。</p><blockquote><p><a href="http://games-cn.org/forums/topic/gainianyihuoblinnphongdaobrdfzhijiandelianxihequbieshishenme/">Blinnphong到BRDF之间的联系和区别是什么？</a></p><p>BSDF/BRDF是一种描述光线打到表面后散射现象，从而描述物体的表面性质的物理概念。<br>Phong/Blinn-Phong是一种<strong>基于经验</strong>的BSDF模型，之后学习的比如Diffuse(Matte),Glass,Mirror等等是一些，基于物理的BSDF模型。<br>Phong/Blinn-Phong模型对物体表面的建模不基于物理，所以可能导致能量不守恒等问题。</p><ul><li>双向反射分布函数(Bidirectional Reflectance Distribution Function,BRDF)</li><li>双向散射分布函数（Bidirectional scattering distribution function, BSDF）</li></ul></blockquote><p>Phong光照模型需要<code>vDirWS</code>和<code>rDirWS</code>，其中光反射方向的计算，需要用<code>reflect()</code>方法。具体原理是光照到物体表面，根据法线方向进行反射。Phong模型计算光反射方向和视角方向的重叠角度，角度越小，高光越强。注意，<code>lDirWS</code>实际上是从模型到光源方向，进行反射计算要反向。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float3 lDirWS &#x3D; _WorldSpaceLightPos0.xyz;</span><br><span class="line">float3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);  &#x2F;&#x2F; 世界空间视线方向</span><br><span class="line">float3 lrDirWS &#x3D; reflect(-lDirWS, nDirWS);</span><br><span class="line">float vdotr &#x3D; dot(vDirWS, lrDirWS);</span><br><span class="line">...</span><br><span class="line">float phong &#x3D; pow(max(0.0, vdotr), specPow);</span><br></pre></td></tr></table></figure><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307011058.gif" alt="Phong" style="zoom:50%;" /><p>Blinn-Phong光照模型计算的是法线方向和半角方向的重合程度，角度越小，高光越强。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float3 hDirWS &#x3D; normalize(vDirWS + lDirWS);&#x2F;&#x2F; 计算半角方向</span><br><span class="line">float3 ndoth &#x3D; dot(nDirWS,hDirWS);</span><br><span class="line">...</span><br><span class="line">float blinnPhong &#x3D; pow(max(0.0,ndoth),_SpecularPow);</span><br></pre></td></tr></table></figure><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307011050.gif" alt="BlinnPhong" style="zoom:50%;" /><h3 id="Unity中的阴影"><a href="#Unity中的阴影" class="headerlink" title="Unity中的阴影"></a>Unity中的阴影</h3><p>暂且不考虑自定义阴影，直接引用Unity给的。主要注意<strong>引用cginc</strong>,结构体内声明格式，以及在顶点片元着色器中的函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 追加投影相关文件</span><br><span class="line">#include &quot;AutoLight.cginc&quot;</span><br><span class="line">#include &quot;Lighting.cginc&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct VertexOutput &#123;</span><br><span class="line">...</span><br><span class="line">float3 bDirWS : TEXCOORD4;  &#x2F;&#x2F; 世界空间副切线方向</span><br><span class="line">LIGHTING_COORDS(5,6)        &#x2F;&#x2F; 投影相关（参数给TEXCOORD编号，后延2位）</span><br><span class="line">         ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VertexOutput vert (VertexInput v) &#123; &#x2F;&#x2F; 顶点Shader</span><br><span class="line">    ...</span><br><span class="line">TRANSFER_VERTEX_TO_FRAGMENT(o);&#x2F;&#x2F; 投影相关 </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float4 frag(VertexOutput i) : COLOR &#123;   &#x2F;&#x2F; 片元Shader 输出rgba</span><br><span class="line">    ...</span><br><span class="line">    float shadow &#x3D; LIGHT_ATTENUATION(i);&#x2F;&#x2F; 投影相关 </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>直接光照相关组合</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float3 dirLighting &#x3D; (baseCol * lambert + specCol * phong) * _LightColor0 * shadow;</span><br><span class="line">&#x2F;&#x2F; _LightColor0为光照颜色</span><br><span class="line">&#x2F;&#x2F; 漫反射颜色和模型乘，高光颜色和高光模型乘</span><br></pre></td></tr></table></figure><h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><h3 id="环境色"><a href="#环境色" class="headerlink" title="环境色"></a>环境色</h3><p>一个简单的环境色影响。粗略的将环境光分为上部、侧面和底部的颜色，将颜色叠加上去。取值部分需要注意一点，取模型上部，<strong>从世界空间法线方向的y轴取</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 环境光照</span><br><span class="line">float upMask &#x3D; max(0.0, nDirWS.y);      &#x2F;&#x2F; 取得向上部分遮罩</span><br><span class="line">float downMask &#x3D; max(0.0, -nDirWS.y);   &#x2F;&#x2F; 取得向下部分遮罩</span><br><span class="line">float sideMask &#x3D; 1.0-upMask-downMask;     &#x2F;&#x2F; 侧面部分遮罩</span><br><span class="line">float3 envCol &#x3D; _EnvUpCol * upMask +</span><br><span class="line">                _EnvSideCol * sideMask +</span><br><span class="line">                _EnvDownCol * downMask;</span><br><span class="line">float3 envDiff &#x3D; baseCol * envCol * _EnvDiffInt;</span><br></pre></td></tr></table></figure><h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h3><p>菲涅尔反射（Fresnel reflection）用来描述光在不同折射率的介质之间的行为。这里可以简单想象一个水面，直看水可以看到水面以下，但远看水面反射较强。</p><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307014505.png" alt="image-20210307014504350" style="zoom:50%;" /><p>计算和视角方向有关，需要求<code>vdotn</code>即<code>vDirWS</code>和<code>nDirWS</code>的点乘。要突出边缘变化，边缘值应为1，中间为0，所以需要用1减去<code>vdotn</code>。<code>_FresnelPow</code>控制强度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float fresnel &#x3D; pow(max(0.0, 1.0 - vdotn), _FresnelPow);</span><br></pre></td></tr></table></figure><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307015017.gif" alt="fresnel" style="zoom:50%;" /><h3 id="Matcap"><a href="#Matcap" class="headerlink" title="Matcap"></a>Matcap</h3><p>MatCap是Material Capture，材质捕获。使用特定材质球的贴图，作为当前材质的<strong>视图空间</strong>环境贴图，从而实现具有均匀表面着色的反射材质物体的显示。是一个低计算成本的环境反射的方式。</p><p>这相当于将光照结果直接画在图上，需要的时候直接采样取出就可以了。这种Shader有一定的局限性，它可以说是固定光照条件下，从特定方向，特定角度的光照表现结果。优点自然是不用提供光照，不用计算。缺点是不适合相机频繁旋转和角度调节。</p><p>注意取样时范围应为一个圆，uv需要针对视角做处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">float3 nDirVS &#x3D; mul(UNITY_MATRIX_V,float4(nDirWS, 0.0));</span><br><span class="line">float3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);</span><br><span class="line">float2 matcapUV &#x3D; nDirVS.rg * 0.5 + 0.5;&#x2F;&#x2F; 将[-1,1]的方形取值范围，转为半径0.5的圆形</span><br><span class="line">float nDotv &#x3D; dot(nDirWS, vDirWS);</span><br><span class="line">float3 matcap &#x3D; tex2D(_Matcap, matcapUV);&#x2F;&#x2F; 正确取样的颜色</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从这张帖图上采样结果：</p><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307015719.png" alt="matcap" style="zoom:33%;" /><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307015745.gif" alt="matcapgif" style="zoom:50%;" /><h3 id="Cubemap"><a href="#Cubemap" class="headerlink" title="Cubemap"></a>Cubemap</h3><p>天空盒。处理天空盒资源时要注意exr和ldr的处理，还有将分辨率remap到方形。一般来说需要在photoshop等美术软件中进行处理。</p><p>这里面有个概念Mipmap，一个模型身上会有贴图，当我们对这个贴图使用了MipMap技术之后，那么在游戏运行中这个模型的贴图会根据摄像机距离模型的远近而调整不同的不同质量的贴图显示。可以类比LOD。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float3 vrDirWS &#x3D; reflect(-vDirWS, nDirWS);&#x2F;&#x2F; 视线反射方向</span><br><span class="line">float cubemapMip &#x3D; lerp(_CubemapMip, 1.0, var_SpecTex.a); &#x2F;&#x2F; 贴图越亮越光滑</span><br><span class="line">float3 var_Cubemap &#x3D; texCUBElod(_Cubemap, float4(vrDirWS, cubemapMip)).rgb;</span><br></pre></td></tr></table></figure><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307020919.gif" alt="cubemap" style="zoom:66%;" /><h3 id="环境光遮蔽"><a href="#环境光遮蔽" class="headerlink" title="环境光遮蔽"></a>环境光遮蔽</h3><p>熟悉的AO（Ambient Occlusion），或者叫环境闭塞等等…指物体自身的结构会对环境光造成遮挡，从而影响环境光在不同部位的强度。</p><p>这个现象可以抬头看房间两面墙的接缝处，可以看到直角边缘比墙要暗。直接采样AO图乘上去就行了。SSAO一类的东西后面再研究。</p><img src="https://Daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20210307022200.gif" alt="AO" style="zoom:67%;" /><h3 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a>组合</h3><p>ao最后进行遮蔽就可以。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float3 envLighting &#x3D; (envDiff + envSpec) * occlusion;</span><br></pre></td></tr></table></figure><hr><h2 id="代码备忘"><a href="#代码备忘" class="headerlink" title="代码备忘"></a>代码备忘</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shader &quot;Daachun&#x2F;L10&#x2F;OldShcoolPro&quot; &#123;</span><br><span class="line">    Properties &#123;    &#x2F;&#x2F; 材质面板参数</span><br><span class="line">        [Header(Texture)]</span><br><span class="line">            _MainTex        (&quot;RGB:基础颜色 A:环境遮罩&quot;, 2D)         &#x3D; &quot;white&quot;&#123;&#125;</span><br><span class="line">            _NormTex        (&quot;RGB:法线贴图&quot;, 2D)                    &#x3D; &quot;bump&quot;&#123;&#125;</span><br><span class="line">            _SpecTex        (&quot;RGB:高光颜色 A:高光次幂&quot;, 2D)         &#x3D; &quot;gray&quot;&#123;&#125;</span><br><span class="line">            _EmitTex        (&quot;RGB:环境贴图&quot;, 2D)                    &#x3D; &quot;black&quot;&#123;&#125;</span><br><span class="line">            _Cubemap        (&quot;RGB:环境贴图&quot;, Cube)                  &#x3D; &quot;_Skybox&quot;&#123;&#125;</span><br><span class="line">        [Header(Diffuse)]</span><br><span class="line">            _MainCol        (&quot;基本色&quot;,Color)                        &#x3D; (0.5, 0.5, 0.5, 1.0)</span><br><span class="line">            _EnvDiffInt     (&quot;环境漫反射强度&quot;, Range(0,1))          &#x3D; 0.2</span><br><span class="line">            _EnvUpCol       (&quot;环境色天顶颜色&quot;, Color)               &#x3D; (1.0, 1.0, 1.0, 1.0)</span><br><span class="line">            _EnvSideCol     (&quot;环境色水平颜色&quot;, Color)               &#x3D; (0.5, 0.5, 0.5, 1.0)</span><br><span class="line">            _EnvDownCol     (&quot;环境色地表颜色&quot;, Color)               &#x3D; (0.0, 0.0, 0.0, 1.0)</span><br><span class="line">        [Header(Specular)]</span><br><span class="line">            _SpecPow        (&quot;高光次幂&quot;, Range(1, 90))              &#x3D; 30</span><br><span class="line">            _EnvSpecInt     (&quot;环境镜面反射强度&quot;, Range(0, 5))       &#x3D; 0.2</span><br><span class="line">            _FresnelPow     (&quot;菲涅尔次幂&quot;, Range(0, 5))             &#x3D; 1</span><br><span class="line">            _CubemapMip     (&quot;环境球Mip&quot;, Range(1, 7))              &#x3D; 1</span><br><span class="line">        [Header(Emission)]</span><br><span class="line">            _EmitInt        (&quot;自发光强度&quot;, Range(1, 10))            &#x3D; 1</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;</span><br><span class="line">            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            Name &quot;FORWARD&quot;</span><br><span class="line">            Tags &#123;</span><br><span class="line">                &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            &#x2F;&#x2F; 追加投影相关文件</span><br><span class="line">            #include &quot;AutoLight.cginc&quot;</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">            #pragma multi_compile_fwdbase_fullshadows</span><br><span class="line">            #pragma target 3.0</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 输入参数</span><br><span class="line">            &#x2F;&#x2F; Texture</span><br><span class="line">            uniform sampler2D _MainTex;</span><br><span class="line">            uniform sampler2D _NormTex;</span><br><span class="line">            uniform sampler2D _SpecTex;</span><br><span class="line">            uniform sampler2D _EmitTex;</span><br><span class="line">            uniform samplerCUBE _Cubemap;</span><br><span class="line">            &#x2F;&#x2F; Diffuse</span><br><span class="line">            uniform float3 _MainCol;</span><br><span class="line">            uniform float _EnvDiffInt;</span><br><span class="line">            uniform float3 _EnvUpCol;</span><br><span class="line">            uniform float3 _EnvSideCol;</span><br><span class="line">            uniform float3 _EnvDownCol;</span><br><span class="line">            &#x2F;&#x2F; Specular</span><br><span class="line">            uniform float _SpecPow;</span><br><span class="line">            uniform float _FresnelPow;</span><br><span class="line">            uniform float _EnvSpecInt;</span><br><span class="line">            uniform float _CubemapMip;</span><br><span class="line">            &#x2F;&#x2F; Emission</span><br><span class="line">            uniform float _EmitInt;</span><br><span class="line"></span><br><span class="line">            struct VertexInput &#123;</span><br><span class="line">                float4 vertex : POSITION;   &#x2F;&#x2F; 顶点信息</span><br><span class="line">                float3 uv0 : TEXCOORD0;     &#x2F;&#x2F; UV信息</span><br><span class="line">                float4 normal : NORMAL;     &#x2F;&#x2F; 法线信息</span><br><span class="line">                float4 tangent : TANGENT;   &#x2F;&#x2F; 切线信息</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            struct VertexOutput &#123;</span><br><span class="line">                float4 pos : SV_POSITION;   &#x2F;&#x2F; 顶点Shader输出结构</span><br><span class="line">                float2 uv0 : TEXCOORD0;     &#x2F;&#x2F; UV0</span><br><span class="line">                float4 posWS : TEXCOORD1;   &#x2F;&#x2F; 世界空间顶点位置</span><br><span class="line">                float3 nDirWS : TEXCOORD2;  &#x2F;&#x2F; 世界空间法线方向</span><br><span class="line">                float3 tDirWS : TEXCOORD3;  &#x2F;&#x2F; 世界空间切线方向</span><br><span class="line">                float3 bDirWS : TEXCOORD4;  &#x2F;&#x2F; 世界空间副切线方向</span><br><span class="line">                LIGHTING_COORDS(5,6)        &#x2F;&#x2F; 投影相关</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            VertexOutput vert (VertexInput v) &#123; &#x2F;&#x2F; 顶点Shader</span><br><span class="line">                VertexOutput o &#x3D; (VertexOutput)0;</span><br><span class="line">                o.pos &#x3D; UnityObjectToClipPos( v.vertex );           &#x2F;&#x2F; 顶点位置</span><br><span class="line">                o.uv0 &#x3D; v.uv0;                                      &#x2F;&#x2F; 传递UV信息</span><br><span class="line">                o.posWS &#x3D; mul(unity_ObjectToWorld, v.vertex);       &#x2F;&#x2F; 顶点位置</span><br><span class="line">                o.nDirWS &#x3D; UnityObjectToWorldNormal(v.normal);      &#x2F;&#x2F; 法线方向</span><br><span class="line">                o.tDirWS &#x3D; normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz,0.0)).xyz);  &#x2F;&#x2F; 切线方向</span><br><span class="line">                o.bDirWS &#x3D; normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w);  &#x2F;&#x2F; 副切线方向</span><br><span class="line">                TRANSFER_VERTEX_TO_FRAGMENT(o)                      &#x2F;&#x2F; 投影相关 </span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            float4 frag(VertexOutput i) : COLOR &#123;   &#x2F;&#x2F; 片元Shader 输出rgba</span><br><span class="line">                &#x2F;&#x2F; 向量准备</span><br><span class="line">                float3 nDirTS &#x3D; UnpackNormal(tex2D(_NormTex,i.uv0)).rgb;    &#x2F;&#x2F; 切线空间法线方向</span><br><span class="line">                float3x3 TBN &#x3D; float3x3(i.tDirWS, i.bDirWS, i.nDirWS);      &#x2F;&#x2F; TBN矩阵，用于将法线从切线空间转到世界空间</span><br><span class="line">                float3 nDirWS &#x3D; normalize(mul(nDirTS, TBN));                &#x2F;&#x2F; 世界空间法线方向</span><br><span class="line">                float3 vDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);  &#x2F;&#x2F; 世界空间视线方向</span><br><span class="line">                float3 vrDirWS &#x3D; reflect(-vDirWS, nDirWS);                  &#x2F;&#x2F; 视线反射方向</span><br><span class="line">                float3 lDirWS &#x3D; _WorldSpaceLightPos0.xyz;                   &#x2F;&#x2F; 光方向</span><br><span class="line">                float3 lrDirWS &#x3D; reflect(-lDirWS, nDirWS);                  &#x2F;&#x2F; 光方向的反射方向</span><br><span class="line">                &#x2F;&#x2F; 中间量准备</span><br><span class="line">                float ndotl &#x3D; dot(nDirWS, lDirWS);</span><br><span class="line">                float vdotr &#x3D; dot(vDirWS, lrDirWS);</span><br><span class="line">                float vdotn &#x3D; dot(vDirWS, nDirWS);</span><br><span class="line">                &#x2F;&#x2F; 纹理采样</span><br><span class="line">                float4 var_MainTex &#x3D; tex2D(_MainTex, i.uv0);</span><br><span class="line">                float4 var_SpecTex &#x3D; tex2D(_SpecTex, i.uv0);</span><br><span class="line">                float3 var_EmitTex &#x3D; tex2D(_EmitTex, i.uv0).rgb;</span><br><span class="line">                float cubemapMip &#x3D; lerp(_CubemapMip, 1.0, var_SpecTex.a);                   &#x2F;&#x2F; 高光次幂贴图越亮越光滑</span><br><span class="line">                float3 var_Cubemap &#x3D; texCUBElod(_Cubemap, float4(vrDirWS, cubemapMip)).rgb;</span><br><span class="line">                &#x2F;&#x2F; 光照模型</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 直接光照</span><br><span class="line">                float3 baseCol &#x3D; var_MainTex.rgb * _MainCol;</span><br><span class="line">                float lambert &#x3D; max(0.0, ndotl);</span><br><span class="line">                float specCol &#x3D; var_SpecTex.rgb;</span><br><span class="line">                float specPow &#x3D; lerp(1, _SpecPow, var_SpecTex.a);</span><br><span class="line">                float phong &#x3D; pow(max(0.0, vdotr), specPow);</span><br><span class="line">                float shadow &#x3D; LIGHT_ATTENUATION(i);</span><br><span class="line">                float3 dirLighting &#x3D; (baseCol * lambert + specCol * phong) * _LightColor0 * shadow;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 环境光照</span><br><span class="line">                float upMask &#x3D; max(0.0, nDirWS.y);      &#x2F;&#x2F; 取得向上部分遮罩</span><br><span class="line">                float downMask &#x3D; max(0.0, -nDirWS.y);   &#x2F;&#x2F; 取得向下部分遮罩</span><br><span class="line">                float sideMask &#x3D; 1.0-upMask-downMask;     &#x2F;&#x2F; 侧面部分遮罩</span><br><span class="line">                float3 envCol &#x3D; _EnvUpCol * upMask +</span><br><span class="line">                                _EnvSideCol * sideMask +</span><br><span class="line">                                _EnvDownCol * downMask;</span><br><span class="line">                float3 envDiff &#x3D; baseCol * envCol * _EnvDiffInt;</span><br><span class="line">                float fresnel &#x3D; pow(max(0.0, 1.0 - vdotn), _FresnelPow);   &#x2F;&#x2F; 菲涅尔</span><br><span class="line">                float3 envSpec &#x3D; var_Cubemap * fresnel * _EnvSpecInt * var_SpecTex.a;</span><br><span class="line">                float occlusion &#x3D; var_MainTex.a;</span><br><span class="line">                float3 envLighting &#x3D; (envDiff + envSpec) * occlusion;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 自发光</span><br><span class="line">                float3 emission &#x3D; var_EmitTex * _EmitInt;</span><br><span class="line">                &#x2F;&#x2F; 返回值</span><br><span class="line">                float3 finalRGB &#x3D; dirLighting + envLighting + emission;</span><br><span class="line">                return fixed4(finalRGB, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul><li><a href="https://space.bilibili.com/6373917/video">庄懂TA入门</a></li><li><a href="https://games-cn.org/intro-graphics/">GAMES101:现代计算机图形学入门</a></li><li>Unity Shader 入门精要</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[笔记]学习资源记录</title>
      <link href="2021/01/13/%5B%E7%AC%94%E8%AE%B0%5D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95/"/>
      <url>2021/01/13/%5B%E7%AC%94%E8%AE%B0%5D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>人有时还是要逼自己一下的。</p><p>实在做不到，逼逼自己一下也行。 ​​​​</p><!--- more ---><p>VR中的物品招来：<a href="https://www.bilibili.com/video/BV1N64y1u7zY">https://www.bilibili.com/video/BV1N64y1u7zY</a></p><h1 id="Unity相关"><a href="#Unity相关" class="headerlink" title="Unity相关"></a>Unity相关</h1><h2 id="Unity基础"><a href="#Unity基础" class="headerlink" title="Unity基础"></a>Unity基础</h2><ul><li><a href="https://edu.hongliu.cc/index">洪流学堂</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zhuanlan.zhihu.com/p/95013367">人人都是秋名山车神——Unity实现简化版卡丁车漂移</a></li><li><a href="https://www.bilibili.com/read/cv4795696">Unity面试易考题 - C#相关</a></li></ul><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://space.bilibili.com/386224375/channel/detail?cid=84549">【重要】Unity官方-Shader Graph教学系列</a></li><li><input disabled="" type="checkbox"> <a href="https://catlikecoding.com/unity/tutorials/">Unity C# and Shader Tuorials</a></li><li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av70029953">【Unity U3D特效教程】</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av69133855">【Unity U3D教程】复刻《塞尔达传说》shader，附下载 中文字幕</a></li><li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av41316597">【公开课】Shader编程教程</a></li></ul><h2 id="Mesh编程"><a href="#Mesh编程" class="headerlink" title="Mesh编程"></a>Mesh编程</h2><ul><li><input disabled="" type="checkbox"> <a href="https://zhuanlan.zhihu.com/p/38546161">是男人就下100层—Unity实现欢乐球球(上)Mesh生成</a></li><li><input disabled="" type="checkbox"> <a href="https://zhuanlan.zhihu.com/p/41564307">别人过七夕，我在一旁玩泥巴——用Unity复刻《一起玩陶艺》</a></li><li><input disabled="" type="checkbox"> <a href="https://blog.csdn.net/carefreeq/article/details/51555376">[Mesh]代码生成圆柱网格</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/u012565990/article/details/51817439">unity 网格切割算法讲解</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/xoyojank/article/details/54030418">Mesh的平面切割算法</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zhuanlan.zhihu.com/p/96084686">Unity Mesh Basics（Unity Mesh基础）系列翻译汇总</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://answers.unity.com/questions/450272/cutting-a-mesh-into-smaller-pieces.html">Cutting a Mesh Into Smaller Pieces</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://forum.unity.com/threads/mesh-cutting-but-not-just-straight.759674/">Mesh cutting but not just straight!</a></li><li><input checked="" disabled="" type="checkbox"> <a href="http://wiki.unity3d.com/index.php/3d_Math_functions?_ga=2.152795505.931179715.1584756046-248805994.1579318433">3d Math functions</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://docs.unity3d.com/ScriptReference/Mesh.html">Mesh</a></li><li><input disabled="" type="checkbox"> <a href="https://forum.unity.com/threads/splitting-a-mesh-in-two.452057/">Splitting a Mesh in Two</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/DanniSchou/MeshSplitting">DanniSchou/MeshSplitting</a></li><li><input disabled="" type="checkbox"> <a href="http://danni.foxesgames.com/2011/10/02/slicing-tech-demo/#.XnXwEXPiuUk">Slicing Tech Demo</a></li><li><input disabled="" type="checkbox"> <a href="http://danni.foxesgames.com/projects/personal/gladiator-tailes/#.XnXwEXPiuUk">Gladiator Tailes</a></li><li><input disabled="" type="checkbox"> <a href="https://zhuanlan.zhihu.com/p/50638544">Runtime Destruction:实时切割平面网格</a></li></ul><h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><ul><li><input disabled="" type="checkbox"> <a href="https://space.bilibili.com/308864667/channel/detail?cid=86562">渔夫游戏开发教程-帧同步</a></li></ul><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><ul><li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av91393509">【手把手教你】Unity中实现A星寻路算法</a></li></ul><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av90798049">GAMES101-现代计算机图形学入门-闫令琪</a></li></ul><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><ul><li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av48240648">C++面向对象高级开发（全）-侯捷</a></li><li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av68697716">最好的C++教程</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av23857692">【千锋网课】Unity与C#编程语言入门与进阶教程（下）</a></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://www.acwing.com/about/">ACWing</a></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/">LeetCodeCN</a></li><li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av48922404">【算法】算法导论-麻省理工</a></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><input disabled="" type="checkbox"> <a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">图说设计模式</a></li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/av67829097">【免费且完整】【渔夫】游戏开发教程-数学基础（合集）</a></li></ul><h1 id="虚拟现实"><a href="#虚拟现实" class="headerlink" title="虚拟现实"></a>虚拟现实</h1><h2 id="全景"><a href="#全景" class="headerlink" title="全景"></a>全景</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://720yun.com/">720云</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://720yun.com/t/2bd2ejb8mls?scene_id=766811">兰州文理学院VR全景</a></li></ul><h1 id="奇奇怪怪的东西记录"><a href="#奇奇怪怪的东西记录" class="headerlink" title="奇奇怪怪的东西记录"></a>奇奇怪怪的东西记录</h1><h2 id="Win10专业版"><a href="#Win10专业版" class="headerlink" title="Win10专业版"></a>Win10专业版</h2><ol><li>Windows10专业版安装密钥：W269N-WFGWX-YVC9B-4J6C9-T83GX</li><li>更新</li><li>slmgr /skms kms.03k.org</li><li>激活</li></ol><h2 id="值得关注"><a href="#值得关注" class="headerlink" title="值得关注"></a>值得关注</h2><ul><li>[Oskar Stålberg](</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-100层楼摔2个苹果？动态规划框架</title>
      <link href="2020/11/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-100%E5%B1%82%E6%A5%BC%E6%91%942%E4%B8%AA%E8%8B%B9%E6%9E%9C%EF%BC%9F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A1%86%E6%9E%B6/"/>
      <url>2020/11/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-100%E5%B1%82%E6%A5%BC%E6%91%942%E4%B8%AA%E8%8B%B9%E6%9E%9C%EF%BC%9F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一道经典题"><a href="#一道经典题" class="headerlink" title="一道经典题"></a>一道经典题</h1><p>面试的过程也是补全自己的过程，要正视自己的缺点，补足落下的知识，虚心求教，终身学习。</p><blockquote><p>来源：百度面试，Google面试题</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一栋100层高楼,从某一层开始扔下的苹果刚好摔坏,现有两个苹果,试用最简便的方法确定这个恰好摔坏苹果的那层。</p><blockquote><p>一幢 100 层的大楼，给你两个鹰蛋。如果在第 n 层扔下鹰蛋，鹰蛋不碎，那么从第 n-1 层扔鹰蛋，都不碎。这两只鹰蛋一模一样，不碎的话可以扔无数次。最高从哪层楼扔下时鹰蛋不会碎？</p><ol><li>如果有无数个鹰蛋，如何求解？</li><li>如果只有两个鹰蛋，如何求解？</li></ol></blockquote><h2 id="不成熟的思考"><a href="#不成熟的思考" class="headerlink" title="不成熟的思考"></a>不成熟的思考</h2><p>我给出的解答是进行分段，第一个球每10层进行摔，在第n个十层摔碎后，第二个球从第n-1个十层开始从小到大遍历摔，就可以确定恰好摔坏苹果的那层。二分法风险大。</p><p>这个思路是<strong>结果导向</strong>，这是不对的：只确定了恰好摔坏苹果的那层，最坏情况是测试18次。应该详细分析，进行归纳。</p><h3 id="有无数个蛋"><a href="#有无数个蛋" class="headerlink" title="有无数个蛋"></a>有无数个蛋</h3><p>这意味着有无数次试错机会，可以用二分法O(logn)的次数内求解问题。</p><h3 id="如果只有两个蛋"><a href="#如果只有两个蛋" class="headerlink" title="如果只有两个蛋"></a>如果只有两个蛋</h3><p><strong>把楼层等分试探求解</strong></p><p>把楼层分为x等分，用第一蛋从上往下一次试探一个范围，如果第一个鹰蛋破了，则用另一鹰蛋穷举。</p><p>假设把总楼层分成了<code>x</code>等分，每个等分内部有<code>n/x</code>个楼层。在最坏情况下，第一个蛋需要试探<code>x</code>次，第二个蛋则要试探<code>n/x-1</code>次（即在每个等分内做穷举），所以最坏的情况需要的总次数为<code>x+(n/x)-1</code>。</p><p>要获取最坏情况的最小值，需要对总次数<code>x+(n/x)-1</code>求导数，并取0值，求解可以得<code>x=sqrt(n)</code>。</p><blockquote><p>​    (x + n/x -1)’</p><p>=  1-(n/x^2)</p><p>=  0</p><p>解得x=sqrt(n)。</p></blockquote><p>在楼层为100的情况下，可以求出使总次数最小的x=10。也就是采用等分的办法，在楼层总数是100时，10等分时最优情况。</p><p><strong>动态规划</strong></p><p>假设有<code>m</code>楼层，<code>n</code>个鹰蛋，则在第<code>i</code>层试探时会出现两种状态：1. 鹰蛋摔破了，则我们下一步只有<code>n-1</code>个鹰蛋，同时总楼层数也缩减为<code>i-1</code>（因为上面的层数可以直接舍去）；2. 鹰蛋没有摔破，那么鹰蛋总数不变，还是<code>n</code>个，楼层数则缩减为<code>m-i</code>层。</p><p>递归在以下三个状态结束：</p><ol><li>如果鹰蛋只剩1个，那么只能对所有的楼层进行穷举；</li><li>如果楼层是0，那么试探0次；</li><li>如果楼层是1，那么试探1次。</li></ol><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201111230816.png" alt="楼层示意"></p><p>状态转移方程：<code>F(m,n) = MIN&#123;MAX&#123;F(i-1,n-1)+1, F(m-i,n)+1&#125;&#125;&#125;;(0&lt;i&lt;m)</code></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie">labuladong的算法小抄</a></p><p><a href="https://zhuanlan.zhihu.com/p/31628866">程序员小灰-动态规划</a></p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态规划（Dynamic Programming，<strong>简称DP</strong>）是运筹学的一个分支，它是<strong>解决多阶段决策过程最优化的一种数学方法。把多阶段问题变换为一系列相互联系的的单阶段问题，然后逐个加以解决</strong>。</p><p>这里提到动态规划其实是一种数学方法，是求解某类问题的一种方法，而<strong>不是一种特殊的算法</strong>，没有一个标准的数学表达式或明确定义的一种规则。</p><p>总结起来就是一句话：大事化小，小事化了。</p><p>具体来说，动态规划的流程为：<strong>暴力的递归解法 -&gt; 带备忘录的递归解法 -&gt; 迭代的动态规划解法。</strong></p><p>就思考流程来说：<strong>找到状态和选择 -&gt; 明确dp数组/函数的定义 -&gt; 寻找状态之间的关系。</strong></p><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p><strong>1. 问题建模</strong></p><p>每一个步骤中，进行分状态定义，再利用递归简化。动态规划当中包含三个重要的概念：<strong>最优子结构</strong>、<strong>边界</strong>、<strong>状态转移公式</strong>。</p><p><strong>2. 求解问题</strong></p><p>拿一个递归方法举例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解n=8时，Fun返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fun(n<span class="number">-3</span>)+Fun(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用递归的思路直接做，这是一颗二叉树，树的节点个数就是递归方法需要计算的次数（图中最后一步省略了）。这棵二叉树高度是<code>n-1</code>节点个数接近·<code>2^(n-1)</code>，时间复杂度近似看成O(2^n)。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201111235915.png" alt="运算二叉树"></p><h2 id="备忘录算法"><a href="#备忘录算法" class="headerlink" title="备忘录算法"></a>备忘录算法</h2><p>可以看到上方的递归图有些相同的参数被<strong>重复计算</strong>了，例如中间的两个Fun(3)，这样越往下走，重复的越多。优化方式可以<strong>用缓存</strong>，创建一个哈希表，每次将不同参数结果存入，遇到相同参数时，从哈希表中取出即可。这个方法叫做<strong>备忘录算法</strong>。 + </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解num=8时，Fun返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> n, Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; map</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.ContainsKey(n))</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">return</span> map[n];   </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = Fun(n<span class="number">-3</span>,map)+Fun(n<span class="number">-2</span>,map);</span><br><span class="line">        map.Add(n,<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合map是一个备忘录，每次需要计算F(n)的时候，会首先从map中寻找匹配元素，如果存在就直接返回结果，不存在就计算结果，存入备忘录中。时间复杂度和空间复杂度都是O(n)。</p><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>上面那个备忘录算法当然<strong>不是</strong>真正的动态规划实现，可以进一步减小空间复杂度。<strong>思路逆转</strong>，不对F(n)自顶向下做递归，而是自底向上用迭代。<strong>每一次迭代过程中，只要保留之前的两个状态，就可以推导出新的状态。</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 感谢电压酱</span></span><br><span class="line"><span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">4</span>; i &lt; n + <span class="number">3</span> + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">3</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n + <span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="动态规划解题套路框架"><a href="#动态规划解题套路框架" class="headerlink" title="动态规划解题套路框架"></a>动态规划解题套路框架</h2><blockquote><p>LeetCode：<a href="https://leetcode-cn.com/problems/fibonacci-number">509.斐波那契数</a>，<a href="https://leetcode-cn.com/problems/coin-change">322.零钱兑换</a></p></blockquote><p><strong>动态规划问题的一般形式就是求最值</strong>，例如求最长递增子序列，最小编辑距离等。</p><p><strong>求动态规划的核心问题是穷举</strong>。这类问题存在<strong>重叠子问题</strong>，具备<strong>最优子结构</strong>，需要正确的<strong>状态转移方程</strong>。一般来说，写出状态转移方程是最困难的。</p><p>思考框架：明确base case，明确状态，明确选择，定义dp数组/函数的含义。</p><p>代码框架：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] &#x3D; base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值:</span><br><span class="line">for 状态2 in 状态2的所有取值:</span><br><span class="line">for ...</span><br><span class="line">dp[状态1][状态2][...] &#x3D; 求最值(选择1, 选择2 ...)</span><br></pre></td></tr></table></figure><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><blockquote><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>给定 <code>N</code>，计算 <code>F(N)</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2.</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 ≤ <code>N</code> ≤ 30</li></ul></blockquote><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">fib</span>(<span class="params"><span class="built_in">int</span> N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span> || N==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上方的<a href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95">递归方法</a>，可以画出递归树，能够看出比较低效。时间复杂度为：<strong>子问题的个数 乘以 解决一个子问题需要的时间</strong>。子问题个数是递归树中节点的总数O(2^n)，解决子问题的时间是加法O(1)，总时间为两者相乘O(2^n)。可以看到递归树中有大量重复的计算，这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。</p><h3 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h3><p>根据上方的<a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E7%AE%97%E6%B3%95">备忘录算法</a>，添加一个哈希表，直接将答案拿来用（空间换时间）。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">fib</span>(<span class="params"><span class="built_in">int</span> N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; map = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">    map.Add(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    map.Add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> fib(N,map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">fib</span>(<span class="params"><span class="built_in">int</span> N,Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; map</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.ContainsKey(N)) <span class="keyword">return</span> map[N];</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span> = Fib(N<span class="number">-1</span>, map) + Fib(N<span class="number">-2</span>, map);</span><br><span class="line">    map.Add(N,<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带备忘录的递归算法，把一颗存在巨量冗余的递归树“减枝”，极大减少了子问题的个数。时间复杂度是O(n)。这种方法叫做<strong>自顶向下</strong>，而动态规划叫<strong>自底向上</strong>。</p><p>自顶向下是像我们画递归树一样，从要求的大问题向下分解为小问题。而自底向上是从小问题开始往上推，直到推到我们想要的答案。这也就是动态规划一般脱离递归，而由循环迭代完成的原因。</p><h3 id="dp数组的迭代解法"><a href="#dp数组的迭代解法" class="headerlink" title="dp数组的迭代解法"></a>dp数组的迭代解法</h3><p>我们把这个备忘录独立出来成为一张表，叫做DP table，在这张表上完成自底向上即可。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">fib</span>(<span class="params"><span class="built_in">int</span> N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(N&gt;<span class="number">0</span>) dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(N&gt;<span class="number">1</span>) dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201112203207.png" alt="dp数组"></p><p>实际上就是反过来算剪枝的结果。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>实际上是描述问题结构的数学形式：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6b54539705dc61842749cf10bfa80e367c912664.png?alt=media" alt="斐波那契"></p><p>把<code>F(n)</code>想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移。</p><p>可以看出，上面几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，对备忘录或DP表的初始化，都是这个额方程式的不同表现形式。因此，<strong>状态转移方程是解决问题的核心</strong>，且直接代表暴力解法。动态规划问题最困难的就是写出这个暴力解（状态转移方程），接下来优化方法无非是用备忘录或者DP table。</p><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>可以看出，根据斐波那契数列的状态转移方程，当前状态只和前两个状态有关，并不需要那么长的一个DP table来存储所有状态，只要想办法存储之前的两个状态就行了。可以进一步优化，把空间复杂度降为O(1)：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">fib</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> prev = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;=n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h2><p>题目：给出<code>k</code>种面值的硬币，面值分别为<code>c1,c2...ck</code>，每种硬币的数量无限，再给一个总金额<code>amount</code>，问<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，返回-1。方法声明如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// coins中是可选硬币面值，amount是目标金额</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">coinChange</span>(<span class="params"><span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount</span>)</span>;</span><br></pre></td></tr></table></figure><p>例：当<code>k = 3</code>，面值为1，2，5，总金额<code>amount = 11</code>。那么最少需要3枚硬币凑出，即11=5+5+1。</p><p>计算机如何解决这个问题？把所有可能的凑硬币方法琼剧出来，然后找找看最少需要多少枚硬币。</p><h3 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h3><p>这个问题是动态规划问题，因为具有<strong>最优子结构</strong>，即子问题间相互独立：如果想求<code>amount = 11</code>的最少硬币数，只要求出<code>amount = 10</code>的数量，再加1即可（添加一枚面值1的硬币）。因为硬币数量是没有限制的，所以子问题之间没有限制，是相互独立的。</p><p><strong>如何列出正确的状态转移方程？</strong></p><ol><li><strong>确定<em>base case</em></strong>：目标金额<code>amount = 0</code>时算法返回0；</li><li><strong>确定<em>状态</em>，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币面额也是给定的，只有目标金额会不断向base case靠近，因此唯一的状态就是目标金额<code>amount</code>。</li><li><strong>确定<em>选择</em>，也就是导致<em>状态</em>产生变化的行为</strong>。目标金额变化的原因是在选择硬币，每选择一枚硬币，就相当于减少了目标金额。选择硬币的面额，就是选择。</li><li><strong>明确<code>dp</code>函数/数组的定义</strong>。暴力递归是自顶向下的解法，所以会有递归的<code>dp</code>函数，一般来说函数的参数就是状态转移中会变化的量，也就是<em>状态</em>；函数的返回值就是我们要计算的量。因此我们可以这样定义：</li></ol><p><code>dp(n)</code>的定义：输入一个目标金额<code>n</code>，返回凑出目标金额<code>n</code>的最少硬币数量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n</span>):</span></span><br><span class="line"><span class="comment"># base case</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>数学形式的状态转移方程：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media" alt="凑零钱"></p><p>至此暴力法解决，时间复杂度为O(k*n^k)，指数级别。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CoinChange</span>(<span class="params"><span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> dp(coins,amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">dp</span>(<span class="params"><span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> res = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; coins.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sub = dp(coins, amount - coins[i]);</span><br><span class="line">            <span class="keyword">if</span>(sub == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res = Math.Min(res, <span class="number">1</span> + sub);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="built_in">int</span>.MaxValue) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 超时</span></span><br></pre></td></tr></table></figure><h3 id="带备忘录递归"><a href="#带备忘录递归" class="headerlink" title="带备忘录递归"></a>带备忘录递归</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CoinChange</span>(<span class="params"><span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; memo = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> dp(coins,amount,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">dp</span>(<span class="params"><span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount, Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; memo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(memo.ContainsKey(amount)) <span class="keyword">return</span> memo[amount];</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> res = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; coins.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sub = dp(coins, amount - coins[i],memo);</span><br><span class="line">            <span class="keyword">if</span>(sub == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res = Math.Min(res, <span class="number">1</span> + sub);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount] = res != <span class="built_in">int</span>.MaxValue?res:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是很慢，时间复杂度O(kn)。</p><h3 id="dp数组的迭代解法-1"><a href="#dp数组的迭代解法-1" class="headerlink" title="dp数组的迭代解法"></a>dp数组的迭代解法</h3><p>主要问题是<strong>确定dp数组的定义</strong>：当目标金额为<code>i</code>时，至少需要<code>dp[i]</code>枚硬币凑出。</p><p>根据开头的动态规划代码框架可以写出：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CoinChange</span>(<span class="params"><span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">     <span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; amount + <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for循环遍历所有状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dp.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; coins.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i - coins[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i] = Math.Min(dp[i], <span class="number">1</span>+ dp[i - coins[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] != amount + <span class="number">1</span>)? dp[amount]:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201115004711.png" alt="dp数组定义"></p><p><code>dp</code>初始化成<code>amount+1</code>的原因是，凑成<code>amount</code>金额的硬币数最多只可能等于<code>amount</code>（也就是全用1元），所以初始化为<code>amount+1</code>相当于正无穷，可以取最小值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>计算机解决问题的办法就是穷举</strong>，算法设计是先思考“如何穷举”，再追求“如何聪明地穷举”。列出状态转移方程就是解决“如何穷举”，备忘录、DP table就是在追求“如何聪明地穷举”。无非是空间换时间。</p><p>阅读题目时，要往<em>状态</em>和<em>选择</em>上思考，才能对框架产生自己的理解。</p><p><strong>最优子结构性质是动态规划问题的必要条件，因此一般都是要你求最值的</strong>，直接从base case往后推导，以小博大。动态规划就是递推填表格（DP数组）的游戏，将问题转化。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-合理优化Unity的GC</title>
      <link href="2020/11/06/Unity/Unity-%E5%90%88%E7%90%86%E4%BC%98%E5%8C%96Unity%E7%9A%84GC/"/>
      <url>2020/11/06/Unity/Unity-%E5%90%88%E7%90%86%E4%BC%98%E5%8C%96Unity%E7%9A%84GC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开发者必须要对Unity中的GC有一定了解。</p><blockquote><p>文章转载自<a href="https://www.cnblogs.com/zblade/p/6445578.html">zblade的博客</a></p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在游戏运行的时候，数据主要存储在内存中，当游戏的数据在不需要的时候，存储当前数据的内存就可以被回收以再次使用。内存垃圾是指当前废弃数据所占用的内存，垃圾回收（GC）是指将废弃的内存重新回收再次使用的过程。</p><p>Unity中将垃圾回收当作内存管理的一部分，如果游戏中废弃数据占用内存较大，则游戏的性能会受到极大影响，此时垃圾回收会成为游戏性能的一大障碍点。</p><p>本文我们主要学习垃圾回收的机制，垃圾回收如何被触发以及如何提GC收效率来提高游戏的性能。</p><blockquote><p>Unity中自己有GC机制，但是这有时也会成为性能瓶颈之一。了解GC机制，能够帮助我们优化Unity应用。</p></blockquote><h1 id="Unity内存管理机制简介"><a href="#Unity内存管理机制简介" class="headerlink" title="Unity内存管理机制简介"></a>Unity内存管理机制简介</h1><p>要想了解垃圾回收如何工作以及何时被触发，我们首先需要了解Unity的内存管理机制。Unity主要采用自动内存管理的机制，开发时在代码中不需要详细地告诉Unity如何进行内存管理，Unity内部自身会进行内存管理。这和使用C++开发需要随时管理内存相比，有一定的优势，当然带来的劣势就是需要随时关注内存的增长，不要让游戏在手机上跑“飞”了。</p><blockquote><p>C++开发需要随时管理内存。Unity中有内部的GC机制，开发中可以不费力管理内存，但是会有内存的增长，导致失控（丢帧？）。</p></blockquote><p>Unity的自动内存管理可以理解为以下几个部分：</p><ol><li>Unity内部有两个内存管理池：<strong>堆内存</strong>和<strong>堆栈内存</strong>。堆栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。</li><li>Unity中的变量<strong>只会</strong>在堆栈或者堆内存上进行内存分配，变量要么存储在堆栈内存上，要么处于堆内存上。</li><li>只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。</li><li>一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于堆栈上的内存回收及其快速，处于堆上的内存并<strong>不是及时回收</strong>的，此时其对应的内存<strong>依然会被标记为使用状态</strong>。</li><li>垃圾回收主要是<strong>指堆上的内存分配和回收</strong>，Unity中会<strong>定时</strong>对堆内存进行GC操作。</li></ol><blockquote><ul><li>heap存大的和时间长的，stack存小的时间短的。</li><li>变量必定在stack或heap。</li><li>激活变量，内存就被使用，被分配。</li><li>变量不激活，可以回收到内存池。</li><li>stack回收快，heap回收慢。</li><li>GC主要说的是heap的，Unity定时清理。</li></ul></blockquote><p>在了解了GC的过程后，下面详细了解堆内存和堆栈内存的分配和回收机制的差别。</p><h1 id="堆栈内存分配和回收机制"><a href="#堆栈内存分配和回收机制" class="headerlink" title="堆栈内存分配和回收机制"></a>堆栈内存分配和回收机制</h1><p>堆栈上的内存分配和回收十分快捷简单，因为堆栈上只会存储短暂的或者较小的变量。内存分配和回收都会以一种顺序和大小可控制的形式进行。</p><p>堆栈的运行方式就像<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a>: 其本质只是一个数据的集合，数据的进出都以一种固定的方式运行。正是这种简洁性和固定性使得堆栈的操作十分快捷。当数据被存储在堆栈上的时候，只需要简单地在其后进行扩展。当数据失效的时候，只需要将其从堆栈上移除。</p><blockquote><p>stack就是栈，一端固定，先进后出。将容器看成一个米缸，压栈就是从顶上往里面放米，出栈就是取最顶上的米。</p></blockquote><h1 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h1><p>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</p><blockquote><p>heap上可以存的东西类型更多、需求空间不同、保存时间也不同，因此更加复杂。</p></blockquote><p>堆上的变量在存储的时候，主要分为以下几步：</p><ol><li><p>首先，Unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应大小的内存单元；</p></li><li><p>如果没有足够的存储单元，Unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步<strong>缓慢</strong>的操作，如果垃圾回收后有足够大小的内存单元，则进行内存分配。</p></li><li><p>如果<strong>垃圾回收后</strong>并没有足够的内存单元，则Unity会<strong>扩展堆内存</strong>的大小，这步操作会<strong>很缓慢</strong>，然后分配对应大小的内存单元给变量。</p></li></ol><p>堆内存的分配有可能会变得十分缓慢，特别是在需要垃圾回收和堆内存需要扩展的情况下，通常需要减少这样的操作次数。</p><blockquote><p>堆内存分配时，Unity要看地方够不够，有就分配，没有就GC，GC很慢。如果GC后还没有足够的地方，就要扩展，更慢。</p></blockquote><h1 id="垃圾回收时的操作"><a href="#垃圾回收时的操作" class="headerlink" title="垃圾回收时的操作"></a>垃圾回收时的操作</h1><p>当堆内存上一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。</p><p>每次运行GC的时候，主要进行下面的操作：</p><ol><li>GC会检查堆内存上<strong>每个</strong>存储变量；</li><li>对每个变量会检测其<strong>引用</strong>是否处于激活状态；</li><li>如果变量的引用不再处于激活状态，则会被标记为<strong>可回收</strong>；</li><li>被标记的变量会被移除，其所占有的内存会被会受到堆内存上。</li></ol><p>GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</p><blockquote><p>heap上存的多，GC就越慢，因为要遍历每个存储变量和它的引用状态。</p></blockquote><h1 id="何时会触发垃圾回收"><a href="#何时会触发垃圾回收" class="headerlink" title="何时会触发垃圾回收"></a>何时会触发垃圾回收</h1><p>主要有三个操作会触发垃圾回收：</p><ol><li>在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；</li><li>GC会自动的触发，不同平台运行频率不一样；</li><li>GC可以被强制执行。</li></ol><p>特别是在堆内存上进行内存分配时内存单元不足够的时候，GC会被<strong>频繁触发</strong>，这就意味着频繁在堆内存上进行内存分配和回收会触发频繁的GC操作。</p><blockquote><p>我们要对堆内存空间分配十分敏感。</p></blockquote><h1 id="GC操作带来的问题"><a href="#GC操作带来的问题" class="headerlink" title="GC操作带来的问题"></a>GC操作带来的问题</h1><p>在了解GC在Unity内存管理中的作用后，我们需要考虑其带来的问题。最明显的问题是GC操作会需要大量的时间来运行，如果堆内存上有<strong>大量的变量或者引用</strong>需要检查，则检查的操作会<strong>十分缓慢</strong>，这就会使得游戏运行缓慢。其次GC可能会在<strong>关键时候</strong>运行，例如在CPU处于游戏的性能运行关键时刻，此时任何一个额外的操作都可能会带来极大的影响，使得游戏帧率下降。</p><blockquote><p>除了GC操作很慢以外，还有可能在CPU的关键期进行GC，游戏帧率会骤降。</p></blockquote><p>另外一个GC带来的问题是堆内存的<strong>碎片化</strong>。当一个内存单元从堆内存上分配出来，其大小取决于其存储的变量的大小。当该内存被回收到堆内存上的时候，有可能使得堆内存<strong>被分割</strong>成碎片化的单元。也就是说堆内存总体可以使用的内存单元较大，但是<strong>单独的内存单元较小</strong>，在下次内存分配的时候不能找到合适大小的存储单元，这也会触发GC操作或者堆内存扩展操作。</p><blockquote><p>heap上存储的变量释放后，在进行分配会有碎片。如申请32k，heap有32k，但都是碎片化的，也会触发GC。</p></blockquote><p>堆内存碎片会造成两个结果，一个是游戏占用的内存会<strong>越来越大</strong>，一个是GC会<strong>更加频繁</strong>地被触发。</p><h1 id="分析GC带来的问题"><a href="#分析GC带来的问题" class="headerlink" title="分析GC带来的问题"></a>分析GC带来的问题</h1><p>GC操作带来的问题主要表现为<strong>帧率运行低</strong>，<strong>性能间歇中断</strong>或者<strong>降低</strong>。如果游戏有这样的表现，则首先需要打开Unity中的<strong>profiler window</strong>来确定是否是GC造成。</p><p>了解如何运用profiler window，可以参考<a href="https://docs.unity3d.com/cn/current/Manual/ProfilerWindow.html">此处</a>，如果游戏确实是由GC造成的，可以继续阅读下面的内容。</p><blockquote><p>性能分析器窗口可以分析GPU、CPU、内存、渲染和音频的性能。</p></blockquote><h1 id="分析堆内存的分配"><a href="#分析堆内存的分配" class="headerlink" title="分析堆内存的分配"></a>分析堆内存的分配</h1><p>如果GC造成游戏的性能问题，我们需要知道游戏中的哪部分代码会造成GC，内存垃圾在变量不再激活的时候产生，所以首先我们需要知道堆内存上分配的是什么变量。</p><h2 id="堆内存和堆栈内存分配的变量类型"><a href="#堆内存和堆栈内存分配的变量类型" class="headerlink" title="堆内存和堆栈内存分配的变量类型"></a>堆内存和堆栈内存分配的变量类型</h2><p>在Unity中，值类型变量都在堆栈上进行内存分配，其他类型的变量都在堆内存上分配。如果你不知道值类型和引用类型的差别，可以查看<a href="https://unity3d.com/cn/learn/tutorials/topics/scripting/data-types">此处</a>。</p><blockquote><p><a href="https://docs.unity3d.com/cn/current/Manual/UnderstandingAutomaticMemoryManagement.html">这里</a>是Unity文档的自动内存管理相关内容。如果逻辑上是固定大小不可变的值，就考虑定义成值类型。如果逻辑上是可饮用的可变的对象，因定义成引用类型。</p><p>常见的Unity中的值类型与引用类型</p><p><strong>值类型</strong>：</p><ul><li>int、float、bool等</li><li>Vector3、Quaternion是structs，因此是值类型</li><li>枚举（enum）</li></ul><p><strong>引用类型</strong>：</p><ul><li>Transform、GameObject</li><li><strong>string</strong></li><li>class</li><li>数组是引用类型（即使元素是值）</li><li>委托（delegate）</li><li>接口（interface），可以用值类型实现。</li></ul></blockquote><p>下面的代码可以用来理解值类型的分配和释放，其对应的变量在函数调用后会立即回收：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> localInt = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的引用类型的参考代码如下，其对应的变量在GC的时候才回收：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List localList = <span class="keyword">new</span> List();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用Profiler-Window来检测堆内存分配"><a href="#利用Profiler-Window来检测堆内存分配" class="headerlink" title="利用Profiler Window来检测堆内存分配"></a>利用Profiler Window来检测堆内存分配</h2><p>我们可以在profier window中检查堆内存的分配操作：在CPU usage分析窗口中，我们可以检测任何一帧cpu的内存分配情况。其中一个选项是<strong>GC Alloc</strong>，通过分析其来<strong>定位</strong>是什么<strong>函数</strong>造成大量的堆内存分配操作。一旦定位该函数，我们就可以分析解决其造成问题的原因从而减少内存垃圾的产生。现在Unity5.5的版本，还提供了<strong>deep profiler</strong>的方式深度分析GC垃圾的产生。</p><h1 id="降低GC的影响的方法"><a href="#降低GC的影响的方法" class="headerlink" title="降低GC的影响的方法"></a>降低GC的影响的方法</h1><p>大体上来说，我们可以通过三种方法来降低GC的影响：</p><ol><li>减少GC的运行<strong>次数</strong>；</li><li>减少单次GC的运行<strong>时间</strong>；</li><li>将GC的运行时间<strong>延迟</strong>，避免在关键时候触发，比如可以在场景加载的时候调用GC。</li></ol><p>似乎看起来很简单，基于此，我们可以采用三种策略：</p><ol><li><p>对游戏进行<strong>重构</strong>，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</p></li><li><p>降低<strong>堆内存分配和回收</strong>的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存的碎片化。</p></li><li><p>我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响。</p></li></ol><h1 id="减少内存垃圾的数量"><a href="#减少内存垃圾的数量" class="headerlink" title="减少内存垃圾的数量"></a>减少内存垃圾的数量</h1><p>减少内存垃圾主要可以通过一些方法来减少：</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用，这就是缓存。</p><p>例如下面的代码每次调用的时候就会造成堆内存分配，主要是每次都会分配一个新的数组：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Renderer[] allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">ExampleFunction(allRenderers);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比下面的代码，只会生产一个数组用来缓存数据，实现反复利用而不需要造成更多的内存垃圾：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Renderer[] allRenderers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ExampleFunction(allRenderers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要再频繁调用的函数中反复进行堆内存分配"><a href="#不要再频繁调用的函数中反复进行堆内存分配" class="headerlink" title="不要再频繁调用的函数中反复进行堆内存分配"></a>不要再频繁调用的函数中反复进行堆内存分配</h2><p>在MonoBehaviour中，如果我们需要进行堆内存分配，最坏的情况就是在其反复调用的函数中进行堆内存分配，例如<code>Update()</code>和<code>LateUpdate()</code>函数这种每帧都调用的函数，这会造成大量的内存垃圾。我们可以考虑在<code>Start()</code>或者<code>Awake()</code>函数中进行内存分配，这样可以减少内存垃圾。</p><p>下面的例子中，update函数会多次触发内存垃圾的产生：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ExampleGarbageGenerationFunction(transform.position.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个简单的改变，我们可以确保每次在x改变的时候才触发函数调用，这样避免每帧都进行堆内存分配：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> previousTransformPositionX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">float</span> transformPositionX = transform.position.x;</span><br><span class="line">    <span class="keyword">if</span>(transfromPositionX != previousTransformPositionX)</span><br><span class="line">    &#123;<span class="comment">// 保证当x改变时，才触发函数调用</span></span><br><span class="line">        ExampleGarbageGenerationFunction(transformPositionX);</span><br><span class="line">        previousTransformPositionX = trasnformPositionX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的一种方法是在update中采用<strong>计时器</strong>，特别是在运行有规律但是不需要每帧都运行的代码中，例如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ExampleGarbageGeneratiingFunction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过添加一个计时器，我们可以确保每隔1s才触发该函数一次：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> timeSinceLastCalled;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> delay = <span class="number">1f</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timSinceLastCalled += Time.deltaTime;</span><br><span class="line">    <span class="keyword">if</span>(timeSinceLastCalled &gt; delay)</span><br><span class="line">    &#123;</span><br><span class="line">         ExampleGarbageGenerationFunction();</span><br><span class="line">         timeSinceLastCalled = <span class="number">0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样细小的改变，我们可以使得代码运行的更快同时减少内存垃圾的产生。</p><p><strong>附：</strong> 不要忽略这一个方法，在最近的项目性能优化中，我经常采用这样的方法来优化游戏的性能，很多对于固定时间的事件回调函数中，如果每次都分配新的缓存，但是在操作完后并不释放，这样就会造成大量的内存垃圾，对于这样的缓存，最好的办法就是当前周期回调后执行清除或者标志为废弃。</p><blockquote><p>有时确实会觉得这样没有必要，之后需要注意。涉及到GC的new一定要注意。</p></blockquote><h2 id="清除链表"><a href="#清除链表" class="headerlink" title="清除链表"></a>清除链表</h2><p>在堆内存上进行链表的分配的时候，如果该链表需要多次反复的分配，我们可以采用链表的<strong>clear函数</strong>来清空链表从而替代反复多次的创建分配链表。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List myList = <span class="keyword">new</span> List();</span><br><span class="line">    PopulateList(myList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过改进，我们可以将该链表只在第一次创建或者该链表必须重新设置的时候才进行堆内存分配，从而大大减少内存垃圾的产生：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List myList = <span class="keyword">new</span> List();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myList.Clear();</span><br><span class="line">    PopulateList(myList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>即便我们在代码中尽可能地减少堆内存的分配行为，但是如果游戏有大量的对象需要产生和销毁依然会造成GC。对象池技术可以通过重复使用对象来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹这种会频繁生成和销毁的对象。</p><p>要详细的讲解对象池已经超出本文的范围，但是该技术值得我们深入的研究<a href="https://unity3d.com/cn/learn/tutorials/topics/scripting/object-pooling">This tutorial on object pooling on the Unity Learn site</a>对于对象池有详细深入的讲解。</p><blockquote><p>之前做FPS案例时接触过，简单来说就是一个对象的循环利用。在Unity中，可以表现为一个GameObject的多次利用。</p><p>例如：用<code>go.SetActive(false)</code>，并等待下次使用，而不是直接<code>Destory(go)</code>。</p></blockquote><p><strong>附：</strong>对象池技术属于游戏中比较通用的技术，如果有闲余时间，大家可以学习一下这方面的知识。</p><h1 id="造成不必要的堆内存分配的因素"><a href="#造成不必要的堆内存分配的因素" class="headerlink" title="造成不必要的堆内存分配的因素"></a>造成不必要的堆内存分配的因素</h1><p>我们已经知道值类型变量在堆栈上分配，其他的变量在堆内存上分配，但是任然有一些情况下的堆内存分配会让我们感到吃惊。下面让我们分析一些常见的不必要的堆内存分配行为并对其进行优化。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在C#中，<strong>字符串是引用类型变量</strong>而不是值类型变量，即使看起来它是存储字符串的值的。这就意味着字符串会造成一定的内存垃圾，由于代码中经常使用字符串，所以我们需要对其格外小心。</p><p>C#中的字符串是<strong>不可变更的</strong>，也就是说其内部的值在创建后是不可被变更的。每次在对字符串进行操作的时候（例如运用字符串的“加”操作），Unity会<strong>新建</strong>一个字符串用来存储新的字符串，使得<strong>旧的字符串被废弃</strong>，这样就会造成内存垃圾。</p><p>我们可以采用以下的一些方法来最小化字符串的影响：</p><ol><li><p><strong>减少</strong>不必要的字符串的<strong>创建</strong>，如果一个字符串被多次利用，我们可以创建并缓存该字符串。</p></li><li><p><strong>减少</strong>不必要的字符串<strong>操作</strong>，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其<strong>分为两个部分的组件</strong>，对于不变的部分就设置为类似常量字符串即可，见下面的例子。</p></li><li><p>如果我们需要<strong>实时的创建字符串</strong>，我们可以采用StringBuilderClass来代替，<strong>StringBuilder</strong>专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p></li><li><p><strong>移除游戏中的Debug.Log()函数的代码</strong>，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会<strong>创建至少一个字符（空字符）的字符串</strong>。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。</p></li></ol><p>在下面的代码中，在Update函数中会进行一个string的操作，这样的操作就会造成不必要的内存垃圾：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Text timerText;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> timer;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer += Time.deltaTime;</span><br><span class="line">    timerText.text = <span class="string">&quot;Time:&quot;</span>+ timer.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将字符串进行分隔，我们可以剔除字符串的加操作，从而减少不必要的内存垃圾：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Text timerHeaderText;<span class="comment">// 分割成两个Text组件</span></span><br><span class="line"><span class="keyword">public</span> Text timerValueText;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> timer;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timerHeaderText.text = <span class="string">&quot;TIME:&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   timerValueText.text = timer.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>StringBuilder可以看一下<a href="https://blog.csdn.net/yu__jiaoshou/article/details/70473540">这里</a>。</p></blockquote><h2 id="Unity函数调用"><a href="#Unity函数调用" class="headerlink" title="Unity函数调用"></a>Unity函数调用</h2><p>在代码编程中，当我们调用不是我们自己编写的代码，无论是Unity自带的还是插件中的，我们都可能会产生内存垃圾。Unity的某些函数调用会产生内存垃圾，我们在使用的时候需要注意它的使用。</p><p>这儿没有明确的列表指出哪些函数需要注意，每个函数在不同的情况下有不同的使用，所以最好仔细地分析游戏，定位内存垃圾的产生原因以及如何解决问题。有时候<strong>缓存</strong>是一种有效的办法，有时候尽量降低函数的<strong>调用频率</strong>是一种办法，有时候用其他函数来<strong>重构代码</strong>是一种办法。现在来分析Unity中常见的造成堆内存分配的函数调用。</p><p>在Unity中如果函数需要返回一个数组，则一个新的数组会被分配出来用作结果返回，这不容易被注意到，特别是如果该函数含有迭代器，下面的代码中对于每个迭代器都会产生一个新的数组：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; myMesh.normals.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 normal = myMesh.normals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这样的问题，我们可以缓存一个数组的引用，这样只需要分配一个数组就可以实现相同的功能，从而减少内存垃圾的产生：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3[] meshNormals = myMesh.normals;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; meshNormals.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 normal = meshNormals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外另外的一个函数调用<code>GameObject.name</code> 或者 <code>GameObject.tag</code>也会造成预想不到的堆内存分配，这两个函数都会将结果存为新的字符串返回，这就会造成不必要的内存垃圾，对结果进行缓存是一种有效的办法，但是在Unity中都对应的有相关的函数来替代。对于比较gameObject的tag，可以采用<code>GameObject.CompareTag()</code>来替代。</p><blockquote><p><code>CampareTag()</code>这个在项目中很常用了。</p></blockquote><p>在下面的代码中，调用<code>gameobject.tag</code>就会产生内存垃圾：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> playerTag=<span class="string">&quot;Player&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bool</span> isPlayer = other.gameObject.tag == playerTag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用<code>GameObject.CompareTag()</code>可以避免内存垃圾的产生：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> playerTag = <span class="string">&quot;Player&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bool</span> isPlayer = other.gameObject.CompareTag(playerTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不只是<code>GameObject.CompareTag()</code>，Unity中许多其他的函数也可以避免内存垃圾的生成。比如我们可以用<code>Input.GetTouch()</code>和<code>Input.touchCount()</code>来代替<code>Input.touches</code>，或者用<code>Physics.SphereCastNonAlloc()</code>来代替<code>Physics.SphereCastAll()</code>。</p><h2 id="装箱操作"><a href="#装箱操作" class="headerlink" title="装箱操作"></a>装箱操作</h2><p>装箱操作是指一个<strong>值类型变量被用作引用类型变量</strong>时候的内部变换过程，如果我们<strong>向带有对象类型参数的函数传入值类型</strong>，这就会触发装箱操作。比如<code>String.Format()</code>函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。如下面代码所示：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> cost = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">string</span> displayString = String.Format(<span class="string">&quot;Price:&#123;0&#125; gold&quot;</span>,cost); <span class="comment">// 对string传入了int，触发了装箱。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Unity的装箱操作中，对于值类型会在堆内存上分配一个<code>System.Object</code>类型的引用来封装该值类型变量，其对应的缓存就会产生内存垃圾。装箱操作是非常普遍的一种产生内存垃圾的行为，即使代码中没有直接的对变量进行装箱操作，在<strong>插件</strong>或者<strong>其他的函数中</strong>也有可能会产生。最好的解决办法是尽可能的避免或者移除造成装箱操作的代码。</p><blockquote><p>这意味着需要优化插件，这可太酷了…</p></blockquote><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>调用 <code> StartCoroutine()</code>会产生少量的内存垃圾，因为Unity会生成实体来管理协程。所以在游戏的关键时刻应该限制该函数的调用。基于此，任何在游戏关键时刻调用的协程都需要特别的注意，特别是包含延迟回调的协程。</p><p>yield在协程中不会产生堆内存分配，但是如果yield带有参数返回，则会造成不必要的内存垃圾，例如：<code>yield return 0;</code></p><p>由于需要返回0，引发了装箱操作，所以会产生内存垃圾。这种情况下，为了避免内存垃圾，我们可以这样返回：<code>yield return null;</code></p><p><strong>另外一种对协程的错误使用是每次返回的时候都new同一个变量</strong>，例如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isComplete)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以采用缓存来避免这样的内存垃圾产生：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">WaitForSeconds delay = <span class="keyword">new</span> WaiForSeconds(<span class="number">1f</span>);</span><br><span class="line"><span class="keyword">while</span>(!isComplete)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里学到了，可以缓存起来这个delay。</p></blockquote><p>如果游戏中的协程产生了内存垃圾，我们可以考虑用其他的方式来<strong>替代协程</strong>。重构代码对于游戏而言十分复杂，但是对于协程而言我们也可以注意一些常见的操作，比如如果用协程来管理时间，最好在update函数中保持对时间的记录。如果用协程来控制游戏中事件的发生顺序，最好对于不同事件之间有一定的信息通信的方式。对于协程而言没有适合各种情况的方法，只有根据具体的代码来选择最好的解决办法。</p><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><p>在<strong>Unity5.5以前</strong>的版本中，在foreach的迭代中都会生成内存垃圾，主要来自于其后的装箱操作。每次在foreach迭代的时候，都会在堆内存上生产一个<code>System.Object</code>用来实现迭代循环操作。在Unity5.5中解决了这个问题，比如，在Unity5.5以前的版本中，用foreach实现循环：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params">List listOfInts</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> currentInt <span class="keyword">in</span> listOfInts)</span><br><span class="line">    &#123;</span><br><span class="line">        DoSomething(currentInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果游戏工程不能升级到5.5以上，则可以用for或者while循环来解决这个问题，所以可以改为：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>(<span class="params">List listOfInts</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; listOfInts.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> currentInt = listOfInts[i];</span><br><span class="line">        DoSomething(currentInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LINQ和常量表达式"><a href="#LINQ和常量表达式" class="headerlink" title="LINQ和常量表达式"></a>LINQ和常量表达式</h2><p>由于LINQ和常量表达式以装箱的方式实现，所以在使用的时候最好进行性能测试。</p><h1 id="重构代码来减小GC的影响"><a href="#重构代码来减小GC的影响" class="headerlink" title="重构代码来减小GC的影响"></a>重构代码来减小GC的影响</h1><p>即使我们减小了代码在堆内存上的分配操作，代码也会增加GC的工作量。最常见的增加GC工作量的方式是让其检查它不必检查的对象。struct是值类型的变量，但是如果struct中包含有引用类型的变量，那么GC就必须检测整个struct。如果这样的操作很多，那么GC的工作量就大大增加。在下面的例子中struct包含一个string，那么整个struct都必须在GC中被检查：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ItemData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> cost;</span><br><span class="line">    <span class="keyword">public</span> Vector3 position;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ItemData[] itemData;</span><br></pre></td></tr></table></figure><blockquote><p>虽然struct是值类型，但如果它包含引用变量，那就GC需要遍历struct了。</p></blockquote><p>我们可以将该struct<strong>拆分</strong>为多个数组的形式，从而减小GC的工作量：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] itemNames;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] itemCosts;</span><br><span class="line"><span class="keyword">private</span> Vector3[] itemPositions;</span><br></pre></td></tr></table></figure><p>另外一种在代码中增加GC工作量的方式是保存不必要的Object引用，在进行GC操作的时候会对堆内存上的object引用进行检查，越少的引用就意味着越少的检查工作量。在下面的例子中，当前的对话框中包含一个对下一个对话框引用，这就使得GC的时候会去检查下一个对象框：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DialogData</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">private</span> DialogData nextDialog;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> DialogData <span class="title">GetNextDialog</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">           <span class="keyword">return</span> nextDialog;           </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过重构代码，我们可以返回下一个对话框实体的标记，而不是对话框实体本身，这样就没有多余的object引用，从而减少GC的工作量：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DialogData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> nextDialogID;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetNextDialogID</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">       <span class="keyword">return</span> nextDialogID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个例子本身并不重要，但是如果我们的游戏中包含大量的含有对其他Object引用的object，我们可以考虑通过重构代码来减少GC的工作量。</p><blockquote><p>这里的意思是不要自己引用自己？可以引用值类型的ID。那么对于单例如何优化？是要做出取舍吗？</p></blockquote><h1 id="定时执行GC操作"><a href="#定时执行GC操作" class="headerlink" title="定时执行GC操作"></a>定时执行GC操作</h1><h2 id="主动调用GC操作"><a href="#主动调用GC操作" class="headerlink" title="主动调用GC操作"></a>主动调用GC操作</h2><p>如果我们知道堆内存在被分配后并没有被使用，我们希望可以主动地调用GC操作，或者在GC操作并不影响游戏体验的时候（例如场景切换的时候），我们可以主动的调用GC操作：<code>System.GC.Collect()</code></p><p>通过主动的调用，我们可以主动驱使GC操作来回收堆内存。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本文对于unity中的GC有了一定的了解，对于GC对于游戏性能的影响以及如何解决都有一定的了解。通过定位造成GC问题的代码以及代码重构我们可以更有效的管理游戏的内存。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Unity优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-项目约定</title>
      <link href="2020/11/03/Unity/Unity-%E9%A1%B9%E7%9B%AE%E7%BA%A6%E5%AE%9A/"/>
      <url>2020/11/03/Unity/Unity-%E9%A1%B9%E7%9B%AE%E7%BA%A6%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>来源：<a href="https://docs.google.com/document/d/1-eUWZ0lWREFu5iH-ggofwnixDDQqalOoT4Yc0NpWR3k/edit#heading=h.23fnzd1otnih">Open Projets:Conventions</a></p></blockquote><blockquote><p>Unity官方的第一个开放项目，项目最终会上架Steam。获取信息可以看<a href="https://github.com/UnityTechnologies/open-project-1">这里</a>。这个标准可以直接拿来用到自己的项目中。</p></blockquote><h1 id="编码（Coding）"><a href="#编码（Coding）" class="headerlink" title="编码（Coding）"></a>编码（Coding）</h1><p>我们使用<a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-type-members">.NET standards</a>作为基础，并在下方进行了更改。</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li><p>使用具有<strong>描述性</strong>和<strong>准确性</strong>的名称（即使这使得名称特别长），这易于阅读，易于移植。</p></li><li><p><u>不要</u>使用<strong>缩写</strong>。</p></li><li><p>使用公认标准的<strong>首字母缩写</strong>，例如：UI，IO。</p></li><li><p>方法名（Method）应为<strong>动词</strong>或者<strong>动词短语</strong>。</p></li><li><p>属性名（Property）应为<strong>名词</strong>、<strong>名词短语</strong>或者<strong>形容词</strong>。</p></li><li><p>布尔值（Boolean）名应为<strong>肯定含义</strong>的短语，你可以在名称前加上诸如“Is”，“Has”，“Can”的前缀，例如：IsActive，CanJump。</p></li><li><p>如果一个物体涉及到使用<strong>多个属性</strong>，使用<strong>物体名称</strong>作为属性名或者作用的前缀，例如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Color _gameTitleColor;</span><br><span class="line">String _gameTitleString;</span><br><span class="line">TextMeshProUGUI _gameTitleText;</span><br></pre></td></tr></table></figure></li><li><p>如果名字不在固定列表中，<u>避免</u>使用<strong>数字</strong>命名。例如：<em>animator1</em>，<em>animator2</em>。命名应<strong>解释</strong>两个属性的不同，例如：<em>playerAnimator</em>，<em>enemyAnimator</em>。</p></li></ul><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><p><strong>定义</strong></p><p>camelCase：第一个字母为小写，之后单词的第一个字母为大写。</p><p>PascalCase：单词的第一个字母都是大写。如果一个单词是有两个字母的缩写，两个字母都大写。如果一个单词是有两个以上字母的缩写，则只有第一个字母大写。</p><ul><li>类、方法、枚举、命名空间、公共字段、公共属性都用<strong>PascalCase</strong>。例如：<code>ClassName</code>，<code>GetValue</code>。</li><li>局部变量，方法参数用<strong>camelCase</strong>。例如：<code>previousValue</code>，<code>mainUI</code>。</li><li>私有字段、私有属性用camelCase，但是要以下划线开头。例如：<code>_inputReader</code>。</li><li>常量全大写，用下划线分割单词。例如：<code>GRAVITY_AMOUNT</code>。</li></ul><h2 id="编程（Programming）"><a href="#编程（Programming）" class="headerlink" title="编程（Programming）"></a>编程（Programming）</h2><ul><li><p>保持字段和方法的<strong>私有性</strong>，除非你<em>需要</em>他们公开。</p></li><li><p>如果你想在Inspector中显示字段，而不想让其它类访问这个变量，不要用<code>public</code>，使用这个attribute：<code>[SerializeField]</code>和<code>private</code>。</p><p><strong>注意：</strong>这样做可能会收到警告：“Field is never assigned to, will always have its default value”，可以用<code>= default</code>来为字段指定默认值。</p></li><li><p>尽量避免使用单例（Singletons），请尝试使用ScriptableObjects（<a href="https://www.youtube.com/watch?v=VBA1QCoEAX4">1</a>，<a href="https://www.youtube.com/watch?v=raQ3iHhE_Kk&ab_channel=Unity">2</a>）来建立一个类似的、集中的、可以从多个对象中访问的类。</p></li><li><p>不要用<code>var</code>来声明变量，要准确声明类型。</p></li><li><p>避免使用静态变量。如果你确定绝对需要他们，请确保它们与<em>Fast Enter Play Mode</em>兼容，详情<a href="https://docs.unity3d.com/2019.3/Documentation/Manual/DomainReloading.html">点击这里</a>。</p></li><li><p>不要在你的代码中使用硬编码的“魔法数字”。例如：角色移动<code>xInput * 0.035f</code>。为什么用这个数字？请将这个数字存储在一个有明确名称的字段中——也许再加个注释说明为什么选择这个特殊数字。</p></li><li><p>提交代码之前，删除所有没使用过的<code>using</code>命令（例如：<code>using System;</code>）。</p></li></ul><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><ul><li><p>每列用<strong>一个Tab</strong>来缩进代码，<u>不要用空格</u>。</p></li><li><p>大括号：如果内容为空，写在同一行。如果非空，每个占一行。例如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmptyBraces</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NonEmptyBraces</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>彼此包含的逻辑关系需要进行缩进，以表示层次。例如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FunctionName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(somethingHappended)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p><strong>重要：</strong>不要画蛇添足。如果你认为任何人看一眼就能明白代码的作用，就<u>不要</u>添加注释。请给你的变量、类、方法起个好名字，让他们自己解释自己！</p></li><li><p>写行内注释为单独一行代码进行补充说明。</p></li><li><p>在每一个类上都要写摘要，以描述类的目的。如果一个类可读性不高、或者功能细节不直观时，可以选择性的在摘要中加入这些细节。例如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This class manages save data</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br></pre></td></tr></table></figure><p>提示：在IDE中输入三个“/”符号，一般会自动生成摘要。看<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/documentation-comments">微软官方规范</a>。</p></li><li><p>方法前写个解释它功能的注释，以防方法名不准确或者添加其他重要细节。你也可以用行内注释，例如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span> This function does this... <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">CalculateBoundingBox</span>(<span class="params"></span>)</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用以<code>//TODO:</code>开头的注释来表示需要稍后完成的事情，这样你就不会忘记它。<strong>注意：</strong>这<u>不是</u>在鼓励你推送未完成的功能。</p></li><li><p>不要写<code>#region</code>或者<code>//--------</code>这类注释。</p></li></ul><h1 id="场景、层次结构"><a href="#场景、层次结构" class="headerlink" title="场景、层次结构"></a>场景、层次结构</h1><h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><ul><li><p>在根（root）上创建空的GameObject并命名，创建视觉上的分隔符。例如：“— Camera —”，“— Environment —”，“— Lighting —”等。给这些分隔符添加“EditorOnly”标签，这样打包的时候就不会加入。</p></li><li><p>用来做容器的空物体，如果它里面只会包含1-2个对象，不要使用。</p></li><li><p>UI部分</p><ul><li><p>尽可能使用同一个Canvas，只有在Canvas属性改变的时候才创建多个Canvas。</p></li><li><p>每一个屏幕创建一个面板（Panel）。例如：主菜单、设置、暂停…</p></li><li><p>用面板（Panel）作为容器，将UI元素进行分组。例如：一个设置标签和它的选项。</p><p>面板能帮忙固定需要固定在一起的元素。例如：一些能量/物品UI在屏幕右下角。</p></li></ul></li></ul><h2 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h2><ul><li><p>在GameObject命名中，不要用空格。</p></li><li><p>用PascalCase命名。例如：MainCharacter，DoorTrigger。</p></li><li><p>如果仅用PascalCase命名会产生歧义，用下划线连接两个概念。例如：MainHall_ExitTrigger，BossMinion_AttackWaypoints。</p></li><li><p><strong>预制体（Prefabs）</strong>：如果合理，可以重新命名实例。例如：一个Prefab Variant文件名称为“Protagonist_Scene1Variant”，如果你只用它一次，可以直接重命名为“Protagonist”。</p><blockquote><p><strong>Prefabs:</strong> Rename instances if it makes sense. Ex: A Prefab Variant file is called Protagonist_Scene1Variant, but once you use it you could rename it just Protagonist.</p></blockquote></li></ul><h1 id="项目资源"><a href="#项目资源" class="headerlink" title="项目资源"></a>项目资源</h1><h2 id="命名-2"><a href="#命名-2" class="headerlink" title="命名"></a>命名</h2><ul><li><p>与<a href="%E5%9C%BA%E6%99%AF%E3%80%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">场景、层次结构</a>规则相同。</p></li><li><p>同一个文件夹下，如果文件相关，使他们名称<strong>自然而然地归为一组</strong>。</p><ul><li>一般来说，用对象所属的事物作为前缀。例如：PlayerAnimationController、PlayerIdle、PlayerRun等。</li><li>如果这样合理的话，你可以使相似的对象保持在一起，即使他们属于不同事物，或者形容词导致他们分开。例如：在一个道具资产文件夹中，你可以用TableRound、TableRectangular来作为名称，这样它们就呆在一起，如果用RoundTable、RectangularTable，他们就不在一起了。</li></ul></li><li><p>避免在名称中使用文件类型。例如：用ShinyMetal代替ShinyMetalMaterial。</p></li></ul><h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><ul><li><p>在根目录，将你的资源放到文件夹中，这些文件夹标识了游戏的区域、系统、位置。你可以创建子文件夹来分割不同类型的资源。</p></li><li><p>场景总是放在Scenes目录下。</p></li><li><p>不属于某个系统的脚本会放在Scripts文件夹目录下，可以建立子文件夹来分类。</p></li><li><p>总而言之：如果一个系统/功能只有脚本，那就在Scripts中创建一个文件夹。如果它有其它类型的资产，就把该文件夹放在根目录下，并按照资产类型添加子文件夹。</p><p>例如：</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201103113812.png" alt="文件夹规范"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 资源 </tag>
            
            <tag> OpenProject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VR开发-Unity2019环境下的Cardboard VR开发</title>
      <link href="2020/10/26/Unity/VR%E5%BC%80%E5%8F%91-Unity2019%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84CardboardVR%E5%BC%80%E5%8F%91/"/>
      <url>2020/10/26/Unity/VR%E5%BC%80%E5%8F%91-Unity2019%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84CardboardVR%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>Google的Cardboard SDK可以将安卓手机变为VR显示设备，配合Cardboard（那种插手机的VR眼镜），可以给用户一个低成本的VR体验。</p><p>然而，Unity在2020版本又一个大刀阔斧的改革：删除了Build-in的VR支持（如下图）。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201026184346.png" alt="Unity删除了Project Settings里面的XR相关"></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="新建项目和导入插件"><a href="#新建项目和导入插件" class="headerlink" title="新建项目和导入插件"></a>新建项目和导入插件</h2><p>这个项目使用的Unity版本是：<strong>Unity 2019.4.13f1c1</strong></p><p>下载Unity现在要通过Unity Hub，并添加Android发布套件。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201026180201.png" alt="Unity2019需要安装Android组件"></p><p>Android开发环境使用自带的OpenJDK。</p><p>我们使用Unity的<strong>Package Manager（包管理器）</strong>来导入SDK。使用这个方法，就<strong>一定要安装Git</strong>。</p><blockquote><ul><li><a href="https://git-scm.com/">Git</a> must be installed and the <code>git</code> executable must be on the <code>PATH</code> environment variable. See <a href="https://docs.unity3d.com/Manual/upm-git.html">Unity’s package manager git support</a> docs for more details.</li></ul></blockquote><p>通过包管理器的<strong>Add package from git URL</strong>选项，将URL粘贴，并添加<strong>Google Cardboard XR Plugin for Unity</strong>这个自定义包。</p><p><code>https://github.com/googlevr/cardboard-xr-plugin.git</code></p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201026184914.png" alt="从github下载自定义包"></p><p>导入后，找到<strong>Samples &gt; Hello Cardboard</strong>，点击Import导入这个案例包。<img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201028092244.png" alt="导入案例包"></p><p>接下来我们就可以在案例中<code>Assets/Samples/Google Cardboard/&lt;version&gt;/Hello Cardboard/Assets/Scenes</code>找到示例场景了。</p><h2 id="项目详细配置"><a href="#项目详细配置" class="headerlink" title="项目详细配置"></a>项目详细配置</h2><blockquote><p>原文档内容：<a href="https://developers.google.com/cardboard/develop/unity/quickstart">Cardboard QuickSstart</a></p></blockquote><p>Unity 2019.3版本之前，我们将GoogleVRForUnity的unitypackage导入项目，并打开Player Settings里面的VR支持，选上Cardboard选项就可以进行开发并打包发布了。但现在这样做就会出错。</p><p>项目需要进行详细的配置，才能进行打包发布。这应该是Unity对Android平台支持逐渐强大、领域也逐渐细分的原因，新的XR支持应该也是原因之一。</p><p>步骤简述：导入包-&gt;设置Build Settings-&gt;设置Player Settings-&gt;修改一些文件</p><p>项目设置步骤：</p><ul><li><p>打开<strong>File &gt; Build Settings</strong> 选择安卓平台并切换。将示例场景加入到打包场景中。</p></li><li><p>找到<strong>Project Settings</strong> &gt; <strong>Player</strong> &gt; <strong>Resolution and Presentation</strong>，将 <strong>Default Orientation</strong> 设置为 <strong>Landscape Left</strong>。</p></li><li><p>找到<strong>Project Settings</strong> &gt; <strong>Player</strong> &gt; <strong>Other Settings</strong>：</p><ol><li><p>Graphics APIs中仅留<code>OpenGLES2</code></p></li><li><p>Scripting Backend中选择<code>IL2CPP</code></p></li><li><p>Target Architectures中选择<code>ARMv7</code>和<code>ARM64</code></p></li><li><p>Internet Access中选择<code>Require</code></p></li></ol></li><li><p>记得设置项目的包名（Package Name）</p></li><li><p>找到 <strong>Project Settings &gt; XR Plug-in Management</strong>，勾选<code>Cardboard XR Plugin</code>。</p></li><li><p>找到 <strong>Project Settings</strong> &gt; <strong>Player</strong> &gt; <strong>Publishing Settings</strong>：勾选<code>Custom Main Gradle Template</code></p></li></ul><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201026191036.png" alt="这块用的少"></p><p>找到这个目录，打开这个文件，在<strong>dependencies</strong>添加以下内容：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.android.support:support-v4:28.0.0&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.google.android.gms:play-services-vision:15.0.2&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.google.protobuf:protobuf-lite:3.0.0&#x27;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">**DEPS**</span><br><span class="line">  implementation <span class="string">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class="line">  implementation <span class="string">&#x27;com.android.support:support-v4:28.0.0&#x27;</span></span><br><span class="line">  implementation <span class="string">&#x27;com.google.android.gms:play-services-vision:15.0.2&#x27;</span></span><br><span class="line">  implementation <span class="string">&#x27;com.google.protobuf:protobuf-lite:3.0.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下Target API Level，如果设置成<code>API Level 29</code>或者<code>Automatic(highest installed)</code>落在了29上，那还要进行以下设置：勾选<code>Custom Main Manifest</code>，在这个文件内添加<code>application</code>的tag：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:requestLegacyExternalStorage</span>=<span class="string">&quot;true&quot;</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此，Android端Cardboard环境配置完毕。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201026193212.png" alt="发布成功"></p><h2 id="一些需要注意的坑"><a href="#一些需要注意的坑" class="headerlink" title="一些需要注意的坑"></a>一些需要注意的坑</h2><ol><li>API LEVEL 29以下的就不要加android:requestLegacyExternalStorage=”true”标签了。</li></ol><h1 id="实现全景"><a href="#实现全景" class="headerlink" title="实现全景"></a>实现全景</h1><h2 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h2><p>找一张全景图，直接拖到天空盒里就行啦！</p><p>这种方式做交互比较麻烦，天空盒很远，比较难对应上位置。</p><h2 id="法线向内的球"><a href="#法线向内的球" class="headerlink" title="法线向内的球"></a>法线向内的球</h2><p>我们通过Blender来简单创建一个法线向内的球，并将全景图贴到这个球上。</p><ol><li><p>Blender中Shift+A创建一个经纬球，右键设置为平滑着色。</p></li><li><p>Tab进入编辑模式，将球全选，选择网格 &gt; 法相 &gt; 翻转。或者全选面，使用快捷键<code>Alt+n</code>选择翻转。你可以在这里查看法线方向，红色是向内。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201026193928.png" alt="视图叠加层"></p></li><li><p>导出fbx模型，导入Unity。</p></li></ol><h2 id="简单改改Shader"><a href="#简单改改Shader" class="headerlink" title="简单改改Shader"></a>简单改改Shader</h2><p>最近有学一些Shader。针对Unity默认的球，我们可以自己写一个Shader设置设置仅正面剔除。</p><p>直接新建一个Standard Surface Shader，别的不用改，加一句剔除正面就可以了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cull Front</span><br></pre></td></tr></table></figure><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201027204318.png" alt="是正面剔除"></p><p>用这个Shader创建一个材质球，放到Unity自带的球上就可以了。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201027224608.png" alt="效果好像还是不太对？内部是正常的"></p><h1 id="实现交互"><a href="#实现交互" class="headerlink" title="实现交互"></a>实现交互</h1><h2 id="凝视交互"><a href="#凝视交互" class="headerlink" title="凝视交互"></a>凝视交互</h2><p>创建一个凝视交互很简单，只要从摄像机发射射线，做一个定时器就可以了。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span> &#123;</span><br><span class="line">     RaycastHit hit;</span><br><span class="line">     <span class="keyword">if</span> (Physics.Raycast(transform.position, transform.forward, <span class="keyword">out</span> hit, MaxDistance))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 新物体</span></span><br><span class="line">         <span class="keyword">if</span>(pointedObject != hit.transform.gameObject)</span><br><span class="line">         &#123;</span><br><span class="line">             pointedObject = hit.transform.gameObject;</span><br><span class="line">             <span class="comment">// 在这里判断射到新物体时的事件</span></span><br><span class="line">             <span class="comment">// OnPointerEnter</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// if(pointedObject.CompareTag(&quot;tag&quot;))&#123; ... &#125;</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         pointedObject = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// OnPointerExit</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>创建一个Canvas，设置为Camera Space，创建两个Image，一个是十字，另一个是圆形进度条。作为圆形进度条的Image，Image Type设置为Filled，并将定时器的时间映射到Fill Amount上就可以了。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20201028085457.png" alt="设置Image Type"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，Unity2019环境下的Cardboard开发还是不难的，麻烦的地方在配置环境，其他照旧。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> VR开发 </tag>
            
            <tag> 虚拟现实 </tag>
            
            <tag> Android </tag>
            
            <tag> Cardboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[笔记]学术论文的语言表达怎样才能更容易发表？</title>
      <link href="2020/09/23/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E8%AF%AD%E8%A8%80%E8%A1%A8%E8%BE%BE%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E6%9B%B4%E5%AE%B9%E6%98%93%E5%8F%91%E8%A1%A8%EF%BC%9F/"/>
      <url>2020/09/23/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E8%AF%AD%E8%A8%80%E8%A1%A8%E8%BE%BE%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E6%9B%B4%E5%AE%B9%E6%98%93%E5%8F%91%E8%A1%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转自<a href="https://www.sohu.com/a/314356462_120151766">https://www.sohu.com/a/314356462_120151766</a></p></blockquote><h1 id="1-学术语言范式"><a href="#1-学术语言范式" class="headerlink" title="1 学术语言范式"></a>1 学术语言范式</h1><h2 id="1-1-学术语言"><a href="#1-1-学术语言" class="headerlink" title="1.1 学术语言"></a>1.1 学术语言</h2><p>学术语言是用来阐述某一领域专业知识的, 通常应该是字典中有的规范的书面用语, 要求科学、准确、规范, 表达清楚不能够产生歧义, 最好不要自己创造一些语意空泛的难解词汇。</p><p>当一篇文章在谈论专业问题的时候, 使用专业词汇是很有必要的, 因为这样业内的人士就可以用尽量简洁的语言表达清楚一个问题, 所以学术语言还应该包含一些专业词汇。</p><p>网络语言一般是混乱、无序和随意的, 日常用语会在不同的语言背景下产生新的含义, 学术语言不同于网络语言和日常用语, 它的规范性决定了不会因时间、背景的不同而产生不同的含义。</p><h2 id="1-2-学术语言表达的误区"><a href="#1-2-学术语言表达的误区" class="headerlink" title="1.2 学术语言表达的误区"></a>1.2 学术语言表达的误区</h2><p>学术语言表达的误区主要来自于互相对立的2种极端情况。</p><p>一种情况是:学术论文通过表达上的“陌生化”手段, 使文章语言晦涩难懂, 让人读起越艰难, 就认为学术水平越高。其实, 这是一种故弄玄虚欺骗读者的伪学术语言。广西师范大学出版社的赵明节先生曾说过:“长期以来, 我有一个明显的感觉, 我们的学术著作大多面孔严肃乃至刻板, 语言瘦硬生涩。大概著作者本来也没怎么弄明白, 一味引用、推演, 越闹越糊涂。我就纳闷了, 这些著作者是不是诚心要让人望而却步、莫测高深?否则, 为什么要把自己精心研究的成果弄得那样云遮雾障甚至面目可憎呢?”毕竟写文章、著书立说不是让人看了头痛才算是高水平的。</p><p>另一种情况是:学术论文的语言就需要严肃、科学、一板一眼, 不需要具有鲜活的生动性。学术论文讲究的是科学和准确, 一些学术问题的描述确实不需要一些如比喻、夸张等修辞手法, 但就学术问题表达上, 一板一眼、枯燥乏味与清晰流畅的表述还是有很大区别的。优秀的学术论文总是能将学术性和可读性融为一体, 任是再复杂、艰深的学术理论, 都能清楚明白地讲给你听, 表述出来不着痕迹, 读者接受起来也不费劲。如果能够达到这种状态, 就是好的学术语言表达方式了。</p><h1 id="2-学术语言表达特征"><a href="#2-学术语言表达特征" class="headerlink" title="2 学术语言表达特征"></a>2 学术语言表达特征</h1><h2 id="2-1-科学性"><a href="#2-1-科学性" class="headerlink" title="2.1 科学性"></a>2.1 科学性</h2><p>学术论文无论是学术型的还是技术型的, 都是阐述一种科学思想、方法, 或是解决某种科学问题, 那么语言表达具有科学性是最基本的要求。</p><p>首先要用真实合理、清晰透明的语言描述问题, 不能弄虚作假。其次是就事论事, 不需要修饰, 不需要用比喻、夸张等修辞手法。学术论文不是文学作品, 文学作品可以发挥想象, 可以夸张性地创作, 以表达作者想表达的主题, 而学术论文要实事求是, 具有科学性。所以, 学术论文语言表达最主要的特征之一就是科学性。</p><h2 id="2-2-准确性"><a href="#2-2-准确性" class="headerlink" title="2.2 准确性"></a>2.2 准确性</h2><p>学术论文具有的科学性, 决定了其语言表达必须思维严密, 表述准确, 意思唯一, 不能产生二义, 这就需要学术论文语言表达必须具有准确性。</p><p>例如, 学术论文中量符号必须使用单个字母表示, 不能用缩写词、英文单词或英文单词词头等超过2个以上的字母来表示。例如, 有的科技期刊把“临界高温”、“临界低温”的量符号分别写作“CHT”“CLT” (它们分别来自“critical high temperature”和“critical low temperature”) , 这是不规范的, 也易误解为C、H、T或C、L、T这3个量相乘。因为数学中2个量相乘是不写乘法符号的, 所以CHT、CLT这个表述就具有了二义性。</p><p>从学术论文的符号语言就可以看出表达准确性的重要, 就是要求意思唯一、不能产生二义性。</p><h2 id="2-3-逻辑性"><a href="#2-3-逻辑性" class="headerlink" title="2.3 逻辑性"></a>2.3 逻辑性</h2><p>针对解决自然科学问题的学术论文, 不能像文学作品那样进行虚构和创作, 除了要求科学性和准确性之外, 逻辑性应该是学术论文另一个比较重要的语言表达特征。</p><p>语言表达的逻辑性包含3个层次:第1层次, 在一句话内要有明显的因果关系和正确的逻辑顺序;第2层次, 段落和段落之间需要有必然的关联性;第3层次, 就全文来讲, 需要环环相扣、脉络清楚、层次清晰。拥有了具有逻辑性的语言表达, 无论再复杂、艰深的学术理论, 读者都能更容易看清楚论文的学术观点。</p><h2 id="2-4-简洁性"><a href="#2-4-简洁性" class="headerlink" title="2.4 简洁性"></a>2.4 简洁性</h2><p>在学术论文语言表达上简单句好于复合句。不管你是否承认, 在学术圈中或多或少有一种认知:认为在语法上比较复合的语言更具有学术气息, 甚至有人提出应该用“标准的复合句” (有2个以上的动词的句子) 作为学术语言, 尤其是英文类的文章。但是, 这种观点本文不能认同。</p><p>多年的编辑工作发现, 有些句子之所以用复合句, 是因为前提条件没有交代清楚, 直接提出主语, 后面只好插入状语、定语等, 甚至是状语从句、定语从句, 将句子变成复合句。如果将时间、地点、条件等信息都分别交代清楚了, 主句就可以用简单句了。</p><p>例如, 编辑出版界的最常用书《科技书刊标准化18讲》, 那么复杂的编辑出版规范方方面面的规定和理由, 都慢慢讲清楚, 随便翻开一页, 都是十几个字的简单句, 很少有动则一两行的大句子。所以, 这样的语言就很清晰、透明, 表述出来不着痕迹, 读者接受起来也不费劲。</p><h1 id="3-语言表达不当引起的后果"><a href="#3-语言表达不当引起的后果" class="headerlink" title="3 语言表达不当引起的后果"></a>3 语言表达不当引起的后果</h1><h2 id="3-1-影响科学思想表达"><a href="#3-1-影响科学思想表达" class="headerlink" title="3.1 影响科学思想表达"></a>3.1 影响科学思想表达</h2><p>学术论文为了表达一种科学思想, 语言是传播科学思想的第一媒介。如果上升一个高度, 进入另一个层次, 可以考虑将学术语言本身看成是学术内容的一部分。本文作者在文献[2]中提出, 可以把学术论文分成学术内涵和学术表达2个方面来看, 无论什么样高大上的学术理论, 都要通过一个良好的学术表达传输给读者。这样看来, 将学术语言表达看成是学术内容的一部分并不过分。既然语言表达与科学思想是一个组合体, 相辅相成, 那么语言表达的重要性就不言而喻了。</p><h2 id="3-2-影响学术信息传播"><a href="#3-2-影响学术信息传播" class="headerlink" title="3.2 影响学术信息传播"></a>3.2 影响学术信息传播</h2><p>学术论文通过学术语言进行学术信息传播, 就要求学术语言精准、科学, 不当的语言表达影响学术信息传播, 甚至发生曲解、误解。学术语言不仅仅指纯文字的语言表达, 在自然科学中, 经常使用的还有符号语言、公式语言、图表语言等。作者应精准使用这所有语言表达方式, 传递论文所要表达的学术信息。</p><h2 id="3-3-影响读者阅读感受"><a href="#3-3-影响读者阅读感受" class="headerlink" title="3.3 影响读者阅读感受"></a>3.3 影响读者阅读感受</h2><p>良好的语言表达, 文学作品读起来可以使人感到如沐春风;学术作品读起来可如涓涓细流, 无声无息渗入心中。总之, 是一种美好的阅读体验。如果文章句子佶屈聱牙、又臭又长、胡乱反复转折, 读者可能如坠迷雾, 不经反复斟酌, 不能理解其意。可想而知, 这又是怎样的一种阅读体验呢。</p><h2 id="3-4-影响期刊整体形象"><a href="#3-4-影响期刊整体形象" class="headerlink" title="3.4 影响期刊整体形象"></a>3.4 影响期刊整体形象</h2><p>在各种期刊评比中, 无论是教育部科技司评选的“精品科技期刊”, 还是中国科学技术信息研究所评选的“百种杰出期刊”, 甚至期刊年审, 语言规范表达都是一个重要指标, 一般3/万的差错率为合格, 1/万的差错率为优秀。学术语言规范、优美的表达是一本期刊的门面, 能够提升期刊的整体形象。</p><h1 id="4-常见的语言表达问题"><a href="#4-常见的语言表达问题" class="headerlink" title="4 常见的语言表达问题"></a>4 常见的语言表达问题</h1><p>在多年的编辑工作中, 经常会遇到一些论文语言表达上的问题, 现整理如下, 与编辑同行们进行分享和交流。</p><ol><li><p>无主句。学术论文就全文思想通常可以使用无主语的句子 (尤其是在摘要中) , 这样的无主句不是没有主语, 因为可以默认句子的主语是本文或本文作者。这可能使得一些作者在语言表达上发生混乱, 在涉及具体问题时使用无主句, 导致句子成分残缺, 意思表达不清楚。</p></li><li><p>句子主干成分分离。在一些学术论文中, 会有句子主干成分分离, 即主谓分离、动词和宾语分离的情况发生。例如, 如图3所示为名义工况为5/36℃、排气温度为52.7℃、回抽量为1 400 kg/h时, 压缩机排气腔内压力信号p1和排气管内压力信号p2随时间的变化。这个句子里主干动词“为”与它的宾语离得太远, 读起来很不顺畅, “为”这个动词一直吊着, 不能落到它的对象上。这不符合学术语言简洁性的特征要求, 原因是那些实验条件没有在之前交代清楚, 而需要在这么长的句子里加在宾语之前。另外, 最好在之前就对p1、p2进行定义, 那么前面那个长句子的主句就可以写成:图3所示为p1和p2随时间的变化;或者p1和p2随时间的变化如图3所示。修改后的句子变成了很清晰的简单句。</p></li></ol><p>句子主干成分分离的情况通常都是一些复合句造成的, 不符合语言表达简洁性要求, 影响阅读感受和对句子的理解。</p><ol start="3"><li><p>双谓语。双谓语借用的是英文中的一种语法错误名称, 就是一个句子中有2个动词。例如, 电压波形是满足实验要求的。例句中“是”和“满足”都是动词, 在这里不应同时出现, 改成:电压波形满足实验要求。修改后的句子意思完整。</p></li><li><p>西化的倒装句。由于很多作者大量阅读英文文献, 受英语语言表达方式的影响, 自然科学学术论文中经常会出现倒装句, 虽然意思能看明白, 但不符合中文语序习惯。所以, 在学术论文语言表达中, 还是提倡使用“主语—谓语—宾语”这样的正序表达, 避免出现生硬的、西化的倒装句。</p></li><li><p>仅用量名称作为图题。在一些学术论文中, 有时作者会直接使用量名称进行叙述, 缺少量的主体, 使句子意思表达不完整, 这种情况在图题和表题上居多。例如, 一个图的名称叫发电功率图。这个图题中只有一个发电功率这个量名称, 虽然其他信息都在图上, 要表达的意思可以看懂, 但仅就图题来说是不合适的。这个图题修改成:晃动摆质量对装置发电功率的影响, 这样信息就比较全面了。</p></li><li><p>并列成分不对等。在一个句子中, 当有并列成分共同搭配使用动词、形容词等时, 需要注意并列成分应当对等, 而且都能与搭配词匹配。例如, 将方均根值电压表的作用与平均值电压表的读数相对比来验证电压波形及计算损耗值[17]。这个句子中“作用”和“读数”对比成分不对等, 不能够并列对比, 并且并列成分较多, 意思表达不清楚。根据原文的意思, 把这个句子修改成:将方均根值电压表与平均值电压表的读数相对比来验证电压波形, 并计算变压器铁芯的损耗。2种电压表的读数是可以比较的, 对比成分对等了, 同时变成2个简单句, 慢慢叙述, 意思就比较清楚了。所以, 在论述一个比较复杂的问题时, 尽量使用简单句, 慢慢叙述, 让人产生娓娓道来的感觉。如果很多成分并列在一起, 句子长, 不好理解, 还容易产生成分不对等的语法错误。</p></li><li><p>量符号使用不当或者量名称使用混乱。在一篇规范的学术论文中, 应该使用国家标准给出的名称及符号表示量, 至少需要符合一般习惯, 不应随意定义。例如, 国家标准中定义电压符号为U, 你就不能够随意定义成D, 而且全文不同处的电压主体符号都必须是U, 差异之处可用上、下角标表示。</p></li></ol><p>另外, 要使用标准的量名称, 且全文统一。例如, 磁感应强度是标准名称, 它还有别名磁密、磁密值、磁通密度, 如果一篇文章中几种名称混用, 那简直是灾难。</p><p>在学术论文中规范使用量名称和符号, 有助于读者对文章的理解, 使阅读变得相对轻松, 是一种好的语言表达方式。</p><h1 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5 结束语"></a>5 结束语</h1><p>综上所述, 学术语言通常应该是字典中有的规范的书面用语, 包含一些专业词汇, 最好不要自己创造一些语意空泛的难解词。学术语言表达最主要的范式是规范性, 同时还应具有科学性、准确性、逻辑性和简洁性等基本特征, 避免陷入伪学术语言表达的误区。准确、优美的语言表达, 不仅可以阐述科学思想、传播学术信息, 还可以给读者带来良好的阅读体验, 以及提升期刊的整体形象。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 学术论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[笔记]Leetcode题型总结</title>
      <link href="2020/08/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-Leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>2020/08/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-Leetcode%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><p>转载自Leetcode<a href="https://leetcode-cn.com/circle/article/48kq9d/">有没有人一起从零开始刷力扣</a>，作者<a href="https://leetcode-cn.com/u/noone_/">noone_</a>。</p></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是不是有许多小伙伴在刷力扣的时候感觉无从下手？从头按顺序开始刷的童鞋们可能会比较有感触，为什么才第四题就感觉很难了?没关系，本文将对力扣的 1-700 题中不需要会员的数据结构与算法题目(数据库与 shell 除外)进行分类，并推荐一个刷题的顺序。</p><h1 id="完全零基础可以刷题吗？"><a href="#完全零基础可以刷题吗？" class="headerlink" title="完全零基础可以刷题吗？"></a>完全零基础可以刷题吗？</h1><p>不能，至少要基本掌握一门计算机语言的语法。但现在在网上随便搜一下就能搜到许多关于计算机语言的教程。当然，最好还是上一下正规的课程。</p><h1 id="刷题顺序很重要吗？"><a href="#刷题顺序很重要吗？" class="headerlink" title="刷题顺序很重要吗？"></a>刷题顺序很重要吗？</h1><p>重要。按照题目类别结构化地刷题的速度不仅更快，而且可以在刷完一类题之后进行总结。对于水平较高的小伙伴们来说，按照推荐的顺序刷，可以在 200 小时内刷完 500 多题。对于萌新们来说，按照推荐顺序刷，能更好地掌握数据结构与算法基础。</p><h1 id="题目分类及刷题顺序推荐"><a href="#题目分类及刷题顺序推荐" class="headerlink" title="题目分类及刷题顺序推荐"></a>题目分类及刷题顺序推荐</h1><h2 id="一-数组"><a href="#一-数组" class="headerlink" title="一. 数组"></a>一. 数组</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数组的遍历</td><td><code>485</code>、<code>495</code>、<code>414</code>、<code>628</code></td></tr><tr><td>统计数组中的元素</td><td><code>645</code>、<code>697</code>、<code>448</code>、<code>442</code>、<code>41</code>、<code>274</code></td></tr><tr><td>数组的改变、移动</td><td><code>453</code>、665、283</td></tr><tr><td>二维数组及滚动数组</td><td>118、119、661、598、419</td></tr><tr><td>数组的旋转</td><td>189、396</td></tr><tr><td>特定顺序遍历二维数组</td><td>54、59、498</td></tr><tr><td>二维数组变换</td><td>566、48、73、289</td></tr><tr><td>前缀和数组</td><td>303、304、238</td></tr><tr><td>题解</td><td><a href="https://leetcode-cn.com/circle/article/oalBEI/">数组篇</a></td></tr></tbody></table><h2 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二. 字符串"></a>二. 字符串</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>字符</td><td>520</td></tr><tr><td>回文串的定义</td><td>125</td></tr><tr><td>公共前缀</td><td>14</td></tr><tr><td>单词</td><td>434、58</td></tr><tr><td>字符串的反转</td><td>344、541、557、151</td></tr><tr><td>字符的统计</td><td>387、389、383、242、49、451、423、657、551、696、467、535</td></tr><tr><td>数字与字符串间转换</td><td>299、412、506、539、553、537、592、640、38、443、8、13、12、273、165、481</td></tr><tr><td>子序列</td><td>392、524、521、522</td></tr><tr><td>高精度运算</td><td>66、67、415、43、306</td></tr><tr><td>字符串变换</td><td>482、6、68</td></tr><tr><td>字符串匹配</td><td>28、686、459、214</td></tr><tr><td>中心拓展法</td><td>5、647</td></tr></tbody></table><h2 id="三-数与位"><a href="#三-数与位" class="headerlink" title="三. 数与位"></a>三. 数与位</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数字的位操作</td><td>7、9、479、564、231、342、326、504、263、190、191、476、461、477、693、393、172、458、258、319、405、171、168、670、233、357、400</td></tr><tr><td>简单数学题</td><td>492、29、507</td></tr><tr><td>快速幂</td><td>50、372</td></tr></tbody></table><h2 id="四-栈与递归"><a href="#四-栈与递归" class="headerlink" title="四. 栈与递归"></a>四. 栈与递归</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>用栈访问最后若干元素</td><td>682、71、388</td></tr><tr><td>栈与计算器</td><td>150、227、224</td></tr><tr><td>栈与括号匹配</td><td>20、636、591、32</td></tr><tr><td>递归</td><td>385、341、394</td></tr></tbody></table><h2 id="五-链表"><a href="#五-链表" class="headerlink" title="五. 链表"></a>五. 链表</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>链表的删除</td><td>203、237、19</td></tr><tr><td>链表的遍历</td><td>430</td></tr><tr><td>链表的旋转与反转</td><td>61、24、206、92、25</td></tr><tr><td>链表高精度加法</td><td>2、445</td></tr><tr><td>链表的合并</td><td>21、23</td></tr></tbody></table><h2 id="六-哈希表"><a href="#六-哈希表" class="headerlink" title="六. 哈希表"></a>六. 哈希表</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>哈希表的查找、插入及删除</td><td>217、633、349、128、202、500、290、532、205、166、466、138</td></tr><tr><td>哈希表与索引</td><td>1、167、599、219、220</td></tr><tr><td>哈希表与统计</td><td>594、350、554、609、454、18</td></tr><tr><td>哈希表与前缀和</td><td>560、523、525</td></tr></tbody></table><h2 id="七-贪心算法"><a href="#七-贪心算法" class="headerlink" title="七. 贪心算法"></a>七. 贪心算法</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数组与贪心算法</td><td>605、121、122、561、455、575、135、409、621、179、56、57、228、452、435、646、406、48、169、215、75、324、517、649、678、420</td></tr><tr><td>子数组与贪心算法</td><td>53、134、581、152</td></tr><tr><td>子序列与贪心算法</td><td>334、376、659</td></tr><tr><td>数字与贪心</td><td>343</td></tr><tr><td>单调栈法</td><td>496、503、456、316、402、321、84、85</td></tr></tbody></table><h2 id="八-双指针法"><a href="#八-双指针法" class="headerlink" title="八. 双指针法"></a>八. 双指针法</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>头尾指针</td><td>345、680、167、15、16、18、11、42</td></tr><tr><td>同向双指针、滑动窗口</td><td>27、26、80、83、82、611、187、643、674、209、3、438、567、424、76、30</td></tr><tr><td>分段双指针</td><td>86、328、160、88、475</td></tr><tr><td>快慢指针</td><td>141、142、143、234、457、287</td></tr></tbody></table><h2 id="九-树"><a href="#九-树" class="headerlink" title="九. 树"></a>九. 树</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>树与递归</td><td>100、222、101、226、437、563、617、508、572、543、654、687、87</td></tr><tr><td>树的层次遍历</td><td>102、429、690、559、662、671、513、515、637、103、107、257、623、653、104、111、112、113、129、404、199、655、116、117</td></tr><tr><td>树的前序遍历</td><td>144、589</td></tr><tr><td>树的前序序列化</td><td>606、331、652、297、449</td></tr><tr><td>树的后序遍历</td><td>145、590</td></tr><tr><td>树的中序遍历与二叉搜索树</td><td>94、700、530、538、230、98、173、669、450、110、95、108、109</td></tr><tr><td>重构二叉树</td><td>105、106</td></tr><tr><td>二叉树的展开</td><td>114</td></tr><tr><td>最近公共祖先</td><td>235、236</td></tr><tr><td>Morris中序遍历</td><td>501、99</td></tr><tr><td>四叉树</td><td>558、427</td></tr></tbody></table><h2 id="十-图与搜索"><a href="#十-图与搜索" class="headerlink" title="十. 图与搜索"></a>十. 图与搜索</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>图的建立与应用</td><td>565</td></tr><tr><td>深度优先搜索</td><td>17、397</td></tr><tr><td>回溯法</td><td>526、401、36、37、51、52、77、39、216、40、46、47、31、556、60、491、78、90、79、93、332</td></tr><tr><td>回溯法与表达式</td><td>241、282、679</td></tr><tr><td>回溯法与括号</td><td>22、301</td></tr><tr><td>回溯法与贪心</td><td>488</td></tr><tr><td>广度优先搜索</td><td>133、200、695、463、542、130、417、529、127、126、433、675</td></tr><tr><td>并查集</td><td>547、684、685</td></tr><tr><td>拓扑排序</td><td>399、207、210</td></tr><tr><td>有限状态自动机</td><td>65、468</td></tr></tbody></table><h2 id="十一-二分查找"><a href="#十一-二分查找" class="headerlink" title="十一. 二分查找"></a>十一. 二分查找</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>二分查找应用(简单)</td><td>374、35、278、367、69、441</td></tr><tr><td>二分查找应用(中等)</td><td>34、540、275、436、300、354、658、162、4</td></tr><tr><td>二分查找与旋转数组</td><td>153、154、33、81</td></tr><tr><td>二分查找与矩阵</td><td>74、240</td></tr><tr><td>二分答案法</td><td>378、668、410、483</td></tr></tbody></table><h2 id="十二-二进制运算的应用"><a href="#十二-二进制运算的应用" class="headerlink" title="十二. 二进制运算的应用"></a>十二. 二进制运算的应用</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>异或的应用</td><td>89、136、137、260、268</td></tr><tr><td>与或非的应用</td><td>371、318、201</td></tr></tbody></table><h2 id="十三-动态规划"><a href="#十三-动态规划" class="headerlink" title="十三. 动态规划"></a>十三. 动态规划</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数组中的动态规划</td><td>509、70、338、45、55、198、213、650、91、639、552、123、188、309、32、264、313、403</td></tr><tr><td>子数组、子序列中的动态规划</td><td>689、413、446、368、416、279</td></tr><tr><td>背包问题</td><td>322、518、474、494、377</td></tr><tr><td>矩阵中的动态规划</td><td>62、63、64、120、576、688、221、629、174、96、329</td></tr><tr><td>动态规划与字符串匹配</td><td>583、72、97、115、516、132、131、139、140、514、10、44</td></tr><tr><td>状态压缩动态规划</td><td>464、691、698、638、473</td></tr><tr><td>区间中的动态规划</td><td>486、664、375、312、546</td></tr><tr><td>树形dp</td><td>337、124</td></tr><tr><td>数位dp</td><td>233、600</td></tr></tbody></table><h2 id="十四-数据结构"><a href="#十四-数据结构" class="headerlink" title="十四. 数据结构"></a>十四. 数据结构</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数据结构设计——栈与队列</td><td>225、232、284、622、641、155</td></tr><tr><td>数据结构设计——哈希表</td><td>676、355、380、381</td></tr><tr><td>数据结构设计——哈希与双向链表</td><td>432、146、460</td></tr><tr><td>前缀树</td><td>208、211、648、386、677、472、421、212、336、440</td></tr><tr><td>堆</td><td>23、373、378、632、347、692、502、630、407、295、480</td></tr><tr><td>树状数组</td><td>307、315、493、327、673</td></tr><tr><td>线段树</td><td>699</td></tr><tr><td>平衡树(set/map)</td><td>352、218、363</td></tr></tbody></table><h2 id="十五-采样"><a href="#十五-采样" class="headerlink" title="十五. 采样"></a>十五. 采样</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>按权值采样</td><td>528、497</td></tr><tr><td>蓄水池抽样</td><td>382、398</td></tr><tr><td>拒绝采样</td><td>470、478、519</td></tr></tbody></table><h2 id="十六-计算几何"><a href="#十六-计算几何" class="headerlink" title="十六. 计算几何"></a>十六. 计算几何</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>计算几何基础</td><td>593、447、223、149</td></tr><tr><td>分类讨论法</td><td>335</td></tr><tr><td>凸包</td><td>587</td></tr><tr><td>覆盖问题</td><td>391</td></tr></tbody></table><h2 id="十七-常用技巧与算法"><a href="#十七-常用技巧与算法" class="headerlink" title="十七. 常用技巧与算法"></a>十七. 常用技巧与算法</h2><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>博弈论</td><td>292</td></tr><tr><td>分块</td><td>239、164</td></tr><tr><td>倍增法</td><td>330</td></tr><tr><td>拓展欧几里得算法</td><td>365</td></tr><tr><td>洗牌算法</td><td>384</td></tr><tr><td>找规律</td><td>390、672</td></tr><tr><td>分治法</td><td>395、667</td></tr><tr><td>排序算法</td><td>147、148</td></tr><tr><td>线性筛</td><td>204</td></tr><tr><td>摩尔投票法</td><td>229</td></tr></tbody></table><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>希望以上的分类及顺序能帮到大家，未来也有做各分类的题解的打算，欢迎一起讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 转载 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[技巧]Win10去除桌面快捷方式小箭头</title>
      <link href="2020/08/04/%E6%9D%82%E8%B0%88/%E6%8A%80%E5%B7%A7-Win10%E5%8E%BB%E9%99%A4%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%AE%AD%E5%A4%B4/"/>
      <url>2020/08/04/%E6%9D%82%E8%B0%88/%E6%8A%80%E5%B7%A7-Win10%E5%8E%BB%E9%99%A4%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%AE%AD%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="YOYO鹿鸣"><a href="#YOYO鹿鸣" class="headerlink" title="YOYO鹿鸣"></a>YOYO鹿鸣</h1><p>最近比较火的<a href="https://space.bilibili.com/488836173">yoyo鹿鸣_Lumi</a>可算掀开了她的马甲，没错，又是米哈游的阴谋！这个号上的视频质量和播放量都非常高<del>都是lsp</del>。（当然早就有大佬找到mhy注册的yoyo鹿鸣的商标了）</p><p>去年有篇米哈游的布料解算的论文发表，这个项目应该算是米哈游的UE4、动捕、布料解算等综合技术的技术展示，质量很高<del>我怀疑跳舞录动作的是妖娆的汉子</del>。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200804185855.png"></p><p><a href="http://geometry.cs.ucl.ac.uk/tuanfeng/">大佬的主页链接</a></p><p>目前来看是html播放的视频，不过后面应该会加上小游戏一类的交互内容，完整版可以再等等。</p><p>目前这个软件跟wallpaper engine、桌面管理软件都有冲突，可以尝鲜一试。</p><p>我自己用的是腾讯桌面管理，自带去快捷方式小箭头，因此装机后也没去改这部分的内容，因此，体验人工桌面的时候就会出现<strong>快捷方式小箭头</strong>和<strong>权限管理盾牌</strong>。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200804191928.png" alt="左手剑 右手盾"></p><p>搜寻资料后在此记录一下比较好的解决方案。</p><h1 id="为什么不推荐删除IsShortcut"><a href="#为什么不推荐删除IsShortcut" class="headerlink" title="为什么不推荐删除IsShortcut"></a>为什么不推荐删除IsShortcut</h1><p>网上找到比较多的方法是<strong>删除注册表IsShortcut键值</strong>的方法来去除快捷方式小箭头，这样会导致很多问题，例如：Win+X菜单打不开，右击计算机图标点管理报错，无法固定到任务栏等。</p><p>打开注册表，找到<code>HKEY_CLASSES_ROOT\Inkfile</code>，删除<code>IsShortcut</code>键值就可以了。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200804192507.png"></p><p>容易造成bug，且比较难还原，不推荐。</p><h1 id="替换成透明Icon"><a href="#替换成透明Icon" class="headerlink" title="替换成透明Icon"></a>替换成透明Icon</h1><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200804195338.png"></p><p>imageres.dll中197这个图标近似于全透明，可以修改注册表的Icon引用，将小箭头或者盾牌图标改成这个197的透明图标。</p><p>可以打开注册表位置<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons</code>在右侧新建<strong>字符串值</strong>，名称为<code>29</code>，内容为<code>C:\WINDOWS\system32\imageres.dll,197</code>。</p><p>盾牌图标想去掉的话，添加一条名为77的键值就可以了，<strong>不建议关闭UAC</strong>。</p><p>我们通过批处理来进行设置，新建一个bat文件，并编辑（或者新建txt，编辑好后将后缀设置成bat）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /d &quot;%systemroot%\system32\imageres.dll,197&quot; /t reg_sz /f</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 77 /d &quot;%systemroot%\system32\imageres.dll,197&quot; /t reg_sz /f</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /q</span><br><span class="line">start explorer</span><br><span class="line">pause</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想恢复的话，将这个位置的注册表键值删除后重启资源管理器就可以了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /f</span><br><span class="line">reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 77 /d &quot;%systemroot%\system32\imageres.dll,197&quot; /t reg_sz /f</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /q</span><br><span class="line">start explorer</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>用<strong>以管理员身份运行</strong>方式运行bat文件就可以了。</p><h1 id="One-more-thing-——-调整Win10-Win8-1桌面图标默认间距"><a href="#One-more-thing-——-调整Win10-Win8-1桌面图标默认间距" class="headerlink" title="One more thing —— 调整Win10/Win8.1桌面图标默认间距"></a>One more thing —— 调整Win10/Win8.1桌面图标默认间距</h1><p>注册表定位到<code>HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics</code>，找到<code>IconSpacing</code>字符串值。</p><p>此处的IconSpacing字符串值代表了桌面图标的水平间距，默认值为：-1125，具体的换算方法为：该值=-15*间距像素值，即-1125代表了桌面图标水平间距为75像素。</p><p>如果修改为-1500，就代表着100像素。</p><p>找到<code>IconVerticalSpacing</code>字符串值。</p><p>该字符串值代表着桌面图标的竖直间距，该值和水平间距值要保持一致。</p><p>重新打开资源管理器就可以了。</p><h1 id="推荐软件Dism"><a href="#推荐软件Dism" class="headerlink" title="推荐软件Dism++"></a>推荐软件Dism++</h1><p><a href="https://www.chuyu.me/zh-Hans/index.html">🔗官网链接</a></p><p>Dism++是强大的 Windows 系统优化工具，它把用户使用、调整频率较高的选项集合到一起，让我们可以使用它快速地完成电脑的自定义设置和优化。</p><p>直接在“系统优化”项下进行设置就可以了。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200804202441.png"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> Win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity]Bolt学习资源推荐</title>
      <link href="2020/08/03/Unity/Unity-Bolt%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90/"/>
      <url>2020/08/03/Unity/Unity-Bolt%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章简单记录一下Bolt自学资源。</p><h1 id="Unity官方Bolt可视化编程工具系列教程"><a href="#Unity官方Bolt可视化编程工具系列教程" class="headerlink" title="Unity官方Bolt可视化编程工具系列教程"></a>Unity官方Bolt可视化编程工具系列教程</h1><p>Unity官方最新的Bolt课程，讲师是M_Studio，质量比较高，建议从这个项目开始学。</p><h2 id="01-教程介绍及准备"><a href="#01-教程介绍及准备" class="headerlink" title="01.教程介绍及准备"></a>01.教程介绍及准备</h2><p><a href="https://www.bilibili.com/video/BV11a4y1a7DX">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV11a4y1a7DX"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="02-实现基本的人物移动"><a href="#02-实现基本的人物移动" class="headerlink" title="02.实现基本的人物移动"></a>02.实现基本的人物移动</h2><p><a href="https://www.bilibili.com/video/BV1UV411B7t6">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1UV411B7t6"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="03-跳跃-地面检测-动画-Gizmos"><a href="#03-跳跃-地面检测-动画-Gizmos" class="headerlink" title="03.跳跃-地面检测-动画-Gizmos"></a>03.跳跃-地面检测-动画-Gizmos</h2><p><a href="https://www.bilibili.com/video/BV1w54y1B7QE">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1w54y1B7QE"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="04-场景加载-数据保存"><a href="#04-场景加载-数据保存" class="headerlink" title="04.场景加载-数据保存"></a>04.场景加载-数据保存</h2><p><a href="https://www.bilibili.com/video/BV1wT4y177hP">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1wT4y177hP"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="05-HUD-获得钥匙开门"><a href="#05-HUD-获得钥匙开门" class="headerlink" title="05.HUD-获得钥匙开门"></a>05.HUD-获得钥匙开门</h2><p><a href="https://www.bilibili.com/video/BV1HA411Y7hw">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1HA411Y7hw"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="06-人物血量更新及状态切换"><a href="#06-人物血量更新及状态切换" class="headerlink" title="06.人物血量更新及状态切换"></a>06.人物血量更新及状态切换</h2><p><a href="https://www.bilibili.com/video/BV1zp4y1q7VW">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1zp4y1q7VW"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="07-短暂无敌-敌人AI巡逻"><a href="#07-短暂无敌-敌人AI巡逻" class="headerlink" title="07.短暂无敌-敌人AI巡逻"></a>07.短暂无敌-敌人AI巡逻</h2><p><a href="https://www.bilibili.com/video/BV1wh411d7gT">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1wh411d7gT"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="08-敌人追击AI"><a href="#08-敌人追击AI" class="headerlink" title="08.敌人追击AI"></a>08.敌人追击AI</h2><p><a href="https://www.bilibili.com/video/BV1nt4y1D7R9">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1nt4y1D7R9"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="09-玩家投掷-敌人死亡"><a href="#09-玩家投掷-敌人死亡" class="headerlink" title="09.玩家投掷 - 敌人死亡"></a>09.玩家投掷 - 敌人死亡</h2><p><a href="https://www.bilibili.com/video/BV1GV411U78i">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1GV411U78i"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h2 id="10-制作菜单及UI互动"><a href="#10-制作菜单及UI互动" class="headerlink" title="10.制作菜单及UI互动"></a>10.制作菜单及UI互动</h2><p><a href="https://www.bilibili.com/video/BV17C4y1t7jq">🔗视频链接</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV17C4y1t7jq"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p>已完结。</p><h1 id="Unity-Learn"><a href="#Unity-Learn" class="headerlink" title="Unity Learn"></a>Unity Learn</h1><p>现在想要学习Unity的知识，你可以第一时间想到B站，但是，可能第二个反应就是Unity Learn。</p><p>Unity Learn已经全面免费，你可以直接观看原来的premium内容！Bolt插件的教学也是有的。</p><p>有以下两个教学：</p><p><a href="https://learn.unity.com/project/bolt-platformer-tutorial?language=en">Bolt - Platformer Tutorial</a></p><p><a href="https://learn.unity.com/tutorial/bolt-videos-archived?language=en#">Bolt Videos [Archived]</a></p><h1 id="Unity可视化编程插件Bolt实用讲解"><a href="#Unity可视化编程插件Bolt实用讲解" class="headerlink" title="Unity可视化编程插件Bolt实用讲解"></a>Unity可视化编程插件Bolt实用讲解</h1><p>夏洛特的Bolt教学，2018年的，比较早了，可以参考着看。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?bvid=BV1CW41157jJ"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 编程 </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity]Bolt免费啦！</title>
      <link href="2020/07/23/Unity/Unity-Bolt%E5%85%8D%E8%B4%B9%E5%95%A6%EF%BC%81/"/>
      <url>2020/07/23/Unity/Unity-Bolt%E5%85%8D%E8%B4%B9%E5%95%A6%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><p>这篇文章并不会详细的写Bolt的使用方法和节点介绍。</p></div><h1 id="早上起来天变了"><a href="#早上起来天变了" class="headerlink" title="早上起来天变了"></a>早上起来天变了</h1><p>今天早上起床，看了眼手机，QQ上各种技术群里面都在传递着同一个消息——Bolt免费了！打开AssetStore的主页，先映入眼帘的就是上方黄色的条幅：<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200723104307.png"></p><p>打开Bolt界面，一个大大的“FREE”拍在了我的脸上。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200723104356.png"></p><p>对这款可视化编程工具我也早有耳闻，但面对较高的售价之前也没有入手。之前听说开发商变成了Unity，群里就在讨论Unity买下来这个估计是为了把它免费出来，到今天果然免费了。</p><p>你问我香不香呢，那肯定是香的，不过对最近买的人可有点不友好。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200723104548.png" alt="不过可以退款"></p><h1 id="可视化编程"><a href="#可视化编程" class="headerlink" title="可视化编程"></a>可视化编程</h1><p>我们都知道Unreal Engine 4的蓝图（Blueprints）是一个很棒的流（flow）式设计的可视化编程插件，常用UE4的大佬可以只用蓝图做一个完成度非常高的作品出来。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200723105203.png"></p><p>这种可视化编程的方式，比面对<del>枯燥的</del>代码直接编程要直观的多，对于新手十分友好，也因此可视化编程也会出现在各种幼儿教育中。</p><h1 id="Bolt和Playmaker"><a href="#Bolt和Playmaker" class="headerlink" title="Bolt和Playmaker"></a>Bolt和Playmaker</h1><p>什么是“流”式设计的可视化变成插件呢？我把它总结成以下几个特点：</p><ul><li>通过graph来创建脚本，一个graph就是一个脚本；</li><li>graph中有节点，每个节点代表一项命令；</li><li>顺序执行，执行完上一个节点后，执行下一个节点（当然，也会有循环）；</li><li>数据可以从一个节点输入给另一个节点。</li></ul><p>在Bolt中，节点就是单元（“Unit”），<strong>实际上就是Unity的各种API命令</strong>，Bolt号称支持所有Unity内置命令，而且可以添加第三方插件的自定义类。可以说这就是Unity版的“蓝图”。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200723105925.png"></p><p>确实，里面还有逻辑判断的节点…</p><p>提到“Unity的蓝图”，我们也不得不提起PlayMaker这个老伙计。这个基于状态机的插件还是比较好理解的，现成的Action库也很多，有一定函数库、代码库积累，效率会比较高。PM的缺点在于代码重用比较困难，可维护性可能会低一些，对数据操作的直接支持比较差，更别说实现设计模式了。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200723111933.png"></p><p>两者的对比下来，Bolt更偏向于编写C#脚本的可视化工具，PM可以通过可视化的状态机来快速实现功能。</p><blockquote><p>我个人还是认为连连看是写Shader的大杀器，编程的话感觉会更麻烦。<br>当然这是因为我不会写Shader Orz</p></blockquote><h1 id="我怎么看？"><a href="#我怎么看？" class="headerlink" title="我怎么看？"></a>我怎么看？</h1><p>我认为Bolt是一个不错的程序入门的起点，同时，也是一个很好的原型制作工具。与其说给程序用，不如说给策划岗用更好一些——将设计交还给设计者，这也是Unity作为一个“全能工具”而不是游戏引擎想要做到的。</p><p>总的来说，如果你已经过了对Unity的API“从0到1”的理解阶段，直接写一个C#脚本可能是更方便的方法…</p><p><del>不过看DOTS还是要提上日程</del></p><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul><li><a href="https://docs.unity3d.com/bolt/1.4/manual/index.html">Bolt文档</a></li><li><a href="https://assetstore.unity.com/packages/tools/visual-scripting/bolt-163802">AssetStore-Bolt</a></li><li><a href="https://docs.unrealengine.com/zh-CN/Resources/Showcases/BlueprintExamples/index.html">UE4蓝图</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 编程 </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MR开发]环境配置的深坑</title>
      <link href="2020/07/12/Unity/MR%E5%BC%80%E5%8F%91-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B7%B1%E5%9D%91/"/>
      <url>2020/07/12/Unity/MR%E5%BC%80%E5%8F%91-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B7%B1%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hololens2开发流程有许多种，官方比较推荐的是通过Unity进行开发、配置和发布，我个人也比较喜欢这个开发路线。</p><p>但是，在最开始的<strong>环境配置</strong>这一步，我就遇到了不少困难。</p><p>这篇文章主要记录一下配置Hololens2开发环境的<strong>正确步骤</strong>，通过以下顺序来配置环境，能让错误尽量最少。</p><p>注意：本篇文章并未涉及Hololens模拟器的安装与配置，相关内容可以参考官方文档。</p><h1 id="先期准备"><a href="#先期准备" class="headerlink" title="先期准备"></a>先期准备</h1><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>请先准备以下软件安装包：</p><ul><li><a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-10-sdk/">Windows 10 SDK</a>，10.0.18362.0版本以上。</li><li><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">Visual Studio 2019</a>，16.2版本以上。</li><li><a href="https://unity3d.com/unity/qa/lts-releases">Unity的LTS版本</a>，推荐2019.4。</li><li><a href="https://github.com/Microsoft/MixedRealityToolkit-Unity/releases">适用于Unity的MRTK v2开发包</a>。</li></ul><h2 id="更新Win10专业版"><a href="#更新Win10专业版" class="headerlink" title="更新Win10专业版"></a>更新Win10专业版</h2><p>除此之外，还请将自己的Windows 10系统更新到专业版及以上，具体的更新步骤如下：</p><ol><li>找一个可以用在自己机器上的Win10专业版激活码：<ul><li>NXRQM-CXV6P-PBGVJ-293T4-R3KTY</li><li>MH37W-N47XK-V7XM9-C7227-GCQG9</li><li>W269N-WFGWX-YVC9B-4J6C9-T83GX</li><li>8N67H-M3CY9-QT7C4-2TR7M-TXYCV</li><li>2B87N-8KFHP-DKV6R-Y2C8J-PKCKT</li></ul></li><li>打开Win10设置-&gt;“更新和安全”-&gt;“激活”菜单，点击“更改产品密钥”来尝试一下上面的激活码，如果显示无效可以换一个再试试。</li><li>根据弹出的提示进行激活或者升级，这种升级是无损升级，等待重启即可。</li><li>安装后具体的激活步骤不再赘述，随便找一个远程kms就可以了。<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712194728.png"></li></ol><h2 id="打开开发者模式"><a href="#打开开发者模式" class="headerlink" title="打开开发者模式"></a>打开开发者模式</h2><p>请打开“更新与安全”-&gt;“开发者选项”，选择<strong>开发人员模式</strong>，并打开<strong>设备门户</strong>和<strong>设备发现</strong>。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712195511.png"></p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712195538.png"></p><h2 id="打开虚拟化，开启Hyper-V"><a href="#打开虚拟化，开启Hyper-V" class="headerlink" title="打开虚拟化，开启Hyper-V"></a>打开虚拟化，开启Hyper-V</h2><p>请先确定Bios中打开了VT开关！</p><p>开始菜单搜索“Hyper-V”，打开“启用或关闭Windows功能”，确保已选择“Hyper-V”。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712195947.png"></p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712200006.png"></p><p>启用功能后，请重启电脑！</p><h1 id="安装软件环境"><a href="#安装软件环境" class="headerlink" title="安装软件环境"></a>安装软件环境</h1><h2 id="1-安装Win10-SDK"><a href="#1-安装Win10-SDK" class="headerlink" title="1. 安装Win10 SDK"></a>1. 安装Win10 SDK</h2><p><strong>一定要先安装Win10 SDK，再安装VS！！</strong></p><p><strong>一定要先安装Win10 SDK，再安装VS！！</strong></p><p><strong>一定要先安装Win10 SDK，再安装VS！！</strong></p><p>将Win10 SDK安装到C盘或者D盘根目录下Windows Kit文件夹中，<strong>保证安装路径比较简短</strong>。</p><p>因为如果按照默认路径安装时，在Unity中进行Build UWP应用会出现“IOException: Win32 IO ……”问题。这就是因为文件在Windows SDK的完整安装路径过长，System.IO.File.Copy无法处理。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712210758.png" alt="IO错误"></p><p>如果你已经安装过WindosSDK，那么安装路径会无法自定义。需要卸载Visual Studio、所有版本的Windows SDK和模拟器，或者重装系统…</p><p>更详细的信息可以看<a href="https://answers.unity.com/questions/1593766/il2cppuwp-strange-error-ioexception-win32-io-retur.html?childToView=1631509#answer-1631509">这里</a>。</p><h2 id="2-安装VS-2019"><a href="#2-安装VS-2019" class="headerlink" title="2. 安装VS 2019"></a>2. 安装VS 2019</h2><p>版本选择社区版就可以了，但是比较重要的是选择哪些开发用的组件。</p><p>需要勾选“使用C++的桌面开发”和“通用Windows平台(UWP)开发”这两个组件，.Net可装可不装。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712212232.png"></p><p>因为我们还会安装Unity，所以也要勾选上“使用Unity的游戏开发”这个组件，不过就不用勾选右侧的Unity版本了，我们自己装。</p><h2 id="3-安装Unity-2019-LTS"><a href="#3-安装Unity-2019-LTS" class="headerlink" title="3. 安装Unity 2019 LTS"></a>3. 安装Unity 2019 LTS</h2><p>安装Unity、注册等步骤不再赘述，需要注意的是，我们要在UnityHub中安装好UWP平台用的Build组件，IL2CPP也推荐安装。<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200712212333.png" alt="勾选UWP的发布组件"></p><p>新建项目后推荐第一时间切换到UWP平台，以防后期素材多了之后切换速度慢。</p><p>到这一步，基本环境就安装完毕了。</p><h2 id="4-项目中导入MRTK开发包"><a href="#4-项目中导入MRTK开发包" class="headerlink" title="4. 项目中导入MRTK开发包"></a>4. 项目中导入MRTK开发包</h2><p>MRTK可以让我们使用Unity快速开发Hololens应用，并通过其中的Build Window窗口进行打包发布。</p><p>打包Appx可以看<a href="#">Post not found: MR开发-appx的打包 这篇文章</a>。</p><p>导入MRTK后需要进行项目设置，具体内容可以看<a href="https://docs.microsoft.com/zh-cn/windows/mixed-reality/mrlearning-base-ch1">官方教程</a>。</p><h1 id="可能会遇到的坑"><a href="#可能会遇到的坑" class="headerlink" title="可能会遇到的坑"></a>可能会遇到的坑</h1><p>Unity打包VS部署Hololens时，报错：找不到WindowsMobile SDK。</p><p>这个问题时源自于VS编译的时候是默认UWP相关SDK在C:\Program Files (x86)\Windows Kits中的，而我们为了打包顺利，将SDK装在了短目录。</p><p>在使用MRTK工具Build Window打包的时候，也会出现这个报错，这是因为这个工具实际上是帮你用VS打包。</p><p>解决方案：</p><p>把下载的WindowsMobile SDK从下载的目录</p><p>[Windows Kit Root Dir]\10\Extension SDKs\WindowsMobile</p><p>拷贝到</p><p>C:\Program Files (x86)\Windows Kits\10\Extension SDKs\</p><p>个人习惯是10目录下的所有东西都拷贝到对应的10目录下，基本就不会出现这个问题了。</p><p>还有些问题可以看看<a href="https://blog.csdn.net/qq_41905133/article/details/88983431">这篇文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MR开发 </tag>
            
            <tag> Hololens </tag>
            
            <tag> 混合现实 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MR开发]appx的打包发布</title>
      <link href="2020/07/08/Unity/MR%E5%BC%80%E5%8F%91-appx%E7%9A%84%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/"/>
      <url>2020/07/08/Unity/MR%E5%BC%80%E5%8F%91-appx%E7%9A%84%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么打包appx？"><a href="#为什么打包appx？" class="headerlink" title="为什么打包appx？"></a>为什么打包appx？</h1><p>如果你的Hololens设备没有在手边，不能通过连接usb线或者本地wifi互联部署项目，打包appx后进行传输是你的最优选择。</p><p>appx格式（或appxbundle格式），是应用程序安装包格式，类似于apk，不过它用于分发、安装应用程序到UWP平台（Windows通用平台）。你的Win10机器上的“照片”，“天气”等应用都属于UWP应用。UWP应用可以从微软商店获取与下载。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708102811.png" alt="UWP应用"></p><div class="note info flat"><p>顺带一提，UWP应用在开始菜单中有“动态磁贴”功能。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708102828.png" alt="动态磁贴"></p></div><p>Hololens2中的所有应用都是UWP应用，因此我们需要打包appx来安装部署我们的应用。</p><h1 id="发布appx"><a href="#发布appx" class="headerlink" title="发布appx"></a>发布appx</h1><p>在使用Unity开发Hololens应用过程中，打包appx有两种方式：通过MRTK工具直接打包，或者通过VS打包。</p><div class="note default flat"><p>我个人比较推荐通过MRTK打包，这样可以略过一个步骤，并且工作流程不需要太多切换。</p></div><h2 id="打包前的环境确认"><a href="#打包前的环境确认" class="headerlink" title="打包前的环境确认"></a>打包前的环境确认</h2><p>你需要确认你的机器上满足以下开发Hololens应用的条件：</p><ul><li>Windows10专业版</li><li>已安装Windows10 SDK 18362+</li><li>Visual Studio 2019</li><li>Unity 2018.4x或Unity 2019</li><li>对应Unity版本的UWP发布组件</li><li>打开旁加载模式（如果本机使用模拟器）</li></ul><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708104414.png" alt="开发人员模式"></p><p>具体需求可以在<a href="https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/GettingStartedWithTheMRTK.html">MRTK插件文档</a>和<a href="https://docs.microsoft.com/zh-cn/windows/mixed-reality/mrtk-getting-started">微软Hololens文档</a>查看。</p><h2 id="通过MRTK打包"><a href="#通过MRTK打包" class="headerlink" title="通过MRTK打包"></a>通过MRTK打包</h2><p>通过MRTK打包发布是十分方便与开心的！只要设置好Player Settings，打开Build Window就可以了！</p><blockquote><p>如何导入MRTK包和如何初始化Hololens的MR项目，在这篇文章中不再赘述。</p></blockquote><p>首先，确定项目设置无误，一定要先将平台转成UWP平台。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708105701.png" alt="转为UWP平台"></p><blockquote><p>Hololens2要选择ARM64</p></blockquote><p>主要确定下图中Publishing Settings里的包名，和下方Capabilities中的内容即可。<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708105157.png" alt="20200708105157"></p><p>之后，打开上方菜单栏’Mixed Reality Toolkit -&gt; Utilities -&gt; Build Window’<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708105258.png" alt="Build Window"></p><p>打开’Appx Build Options’选项卡，直接点击右下角’Build APPX’即可！<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708105903.png"></p><p>点击’Open APPX Packages Location’你可以看到多次打包的项目目录。</p><p>找到刚刚发布版本的文件夹，打开，里面的appx/appxbundle文件就是我们发布的应用程序包。<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708110141.png"></p><h2 id="通过VS打包"><a href="#通过VS打包" class="headerlink" title="通过VS打包"></a>通过VS打包</h2><p>流程和通过VS部署Hololens2程序一样，设置好项目后直接在Build Settings窗口Build即可，可以看<a href="https://docs.microsoft.com/zh-cn/windows/mixed-reality/exporting-and-building-a-unity-visual-studio-solution">这篇文档</a>。</p><p>不同的一点是，我们不通过VS进行远程部署，而是通过VS打包成appx。</p><p>打开发布好的VS项目，将上方平台正确设置（一般是“ARM64”和“Release”——根据Build Settings窗口中的设置），点击’项目 -&gt; 发布 -&gt; 创建应用程序包’，选择“旁加载”，根据提示发布，记得<strong>平台只选择ARM64</strong>。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708111123.png" alt="通过VS打包"></p><h1 id="安装appx"><a href="#安装appx" class="headerlink" title="安装appx"></a>安装appx</h1><p>如何将appx部署到机器上？</p><p>很简单，连接你的Hololens。如果在同一Wifi下，打开设备控制台页面切换至Apps选项卡，找到Deploy apps，选择好appx的安装包，安装即可。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708111720.png" alt="Device Portal"></p><div class="note info flat"><p>连接Hololens设备需要进行配对，一般来说通过浏览器进入设备控制台，忽略证书错误。<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200708111617.png" alt="证书错误"></p><p><a href="https://blog.csdn.net/shanguuncle/article/details/77806731">这篇文章</a>讲了如何连接设备管理门户，注意，Hololens2需要打开“开发人员模式”。</p></div><div class="note info flat"><p>注意：同包名的项目，版本号是判断新旧的唯一标准，如果你想覆盖之前的版本，一定要保证当前版本号高于之前的。</p></div><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/mixed-reality/vuforia-development-overview">将 Vuforia 引擎与 Unity 一起使用</a></li><li><a href="https://library.vuforia.com/articles/Solution/Working-with-the-HoloLens-sample-in-Unity">Vuforia 文档：在 Unity 中使用 HoloLens 示例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MR开发 </tag>
            
            <tag> Hololens </tag>
            
            <tag> 混合现实 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[杂谈]疫情、近况与毕业</title>
      <link href="2020/07/05/%E6%9D%82%E8%B0%88/%E6%9D%82%E8%B0%88-%E7%96%AB%E6%83%85%E3%80%81%E8%BF%91%E5%86%B5%E4%B8%8E%E6%AF%95%E4%B8%9A/"/>
      <url>2020/07/05/%E6%9D%82%E8%B0%88/%E6%9D%82%E8%B0%88-%E7%96%AB%E6%83%85%E3%80%81%E8%BF%91%E5%86%B5%E4%B8%8E%E6%AF%95%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="疫情、袭来"><a href="#疫情、袭来" class="headerlink" title="疫情、袭来"></a>疫情、袭来</h1><p>我算是充分理解了什么叫做“现实有的时候往往比小说更离奇”he了，2020年开局不利，谁能预想到新冠肺炎疫情这一个“黑天鹅”事件的出现呢？</p><p>梳理一下疫情时间线，1月3日中国有关方面向世卫组织、有关国家和地区组织通报新型冠状病毒肺炎疫情的信息；1月23日武汉封城；2月3日方舱医院…</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200706005241.png" alt="国内疫情很严重"></p><p>到现在，疫情已经持续将近七个月（包含去年12月份），而目前来讲国内疫情基本控制，虽然出现了二次爆发的北京疫情，但也在政府的迅速反映下控制住了。但是，全球疫情形势不容乐观，全球累计病例1118多万人，这说明未来在预防境外输入方面压力会很大。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200706005314.png" alt="但是国外的更恐怖"></p><p>疫情同样导致了国际关系的转变，且不说刚放缓的贸易战，现在舆论战正打得如火如荼。疫情所导致的新常态，对中国来说是挑战，也是机遇。在这个时代的我们，应该努力提升自己，做好自己分内的工作，并努力奋斗。</p><h1 id="近况"><a href="#近况" class="headerlink" title="近况"></a>近况</h1><p>肥宅生活十分开心，搞清楚了MR开发主要流程十分开心，项目基本完成十分开心，学习了不少知识也十分开心。</p><p>当然我们还是有很大的学业压力，想要研究出一些新东西还挺难的。不同于本科的“毕设说明书”，研究生的毕业论文更要求专业性和一定的理论高度，并且要从学术角度出发进行创新和实践。虽然对于新兴的XR产业来说，创新相对容易，但将其与传统设计理论结合对我来说还是很有难度的（因为很菜）。不过经过半年的深入学习，内心逐渐有谱，暑假时间要钻研进去了。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/20200706005514.jpg" alt="键盘真的很好看"></p><p>生活方面，买了一个84键位的键盘，自己组装了一个96配列的键盘，换了心心念念的新笔记本，接触了Hololens2实机与开发，很开心。当然，最开心的还是与家人相处的时光，从上大学后，就没有这么长时间与家人在一起了，可能以后开学了，工作了也不会有这么大块时间陪伴父母和老人了。怎么说的，这算是从新的视角重新认识了我的家庭，从中我感到了爱、希望以及奋斗的动力。</p><h1 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h1><p>学姐和学弟毕业了。如果说每年都提“最难毕业季”的话，今年可能是最难的了，疫情影响大批中小企业倒闭，就业岗位一下子就紧张起来。就我的了解，今年毕业的本科学校普遍的就业率在40%左右，当然实际数据没有出来，但数据绝对不会像往年那样漂亮。明天是高考，希望大家都好。</p><p>顺便问一句，瑞幸还有免费的咖啡喝嘛（；´д｀）ゞ</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity]免费的Unity Pro？学生认证申请攻略</title>
      <link href="2020/06/03/Unity/Unity-%E5%85%8D%E8%B4%B9%E7%9A%84Unity%20Pro%EF%BC%9F%E5%AD%A6%E7%94%9F%E8%AE%A4%E8%AF%81%E7%94%B3%E8%AF%B7%E6%94%BB%E7%95%A5/"/>
      <url>2020/06/03/Unity/Unity-%E5%85%8D%E8%B4%B9%E7%9A%84Unity%20Pro%EF%BC%9F%E5%AD%A6%E7%94%9F%E8%AE%A4%E8%AF%81%E7%94%B3%E8%AF%B7%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="首先你要确定…"><a href="#首先你要确定…" class="headerlink" title="首先你要确定…"></a>首先你要确定…</h1><p>先停一下！我知道你很想白嫖UnityPro，开心的使用黑色主题。但是你要先确定你是<strong>在校学生</strong>。</p><p>只有在校学生才能申请这个学生认证噢！</p><p>UnityPro很贵是怎么回事呢？UnityPro相信大家都很熟悉，但是UnityPro很贵是怎么回事呢，下面就让小编带大家一起了解吧。</p><p>UnityPro很贵，其实就是我们没有钱买，大家可能会很惊讶UnityPro怎么会很贵呢？但事实就是这样，小编也感到非常惊讶。</p><p>这就是关于UnityPro很贵的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！</p><p>开玩笑的啦兄弟</p><p>实际上这件事情很简单，Unity和Github算是合作了？只要申请了Github的学生认证，就可以免费获得1年的Unity Pro，同样的Pro有的东西（例如5个高级团队席位，25G的云空间，适用于Pro的服务），这个学生认证送你的Pro中都有。</p><p>这篇文章记录一下里面的步骤和坑。</p><h1 id="获取步骤"><a href="#获取步骤" class="headerlink" title="获取步骤"></a>获取步骤</h1><h2 id="我们需要准备的内容"><a href="#我们需要准备的内容" class="headerlink" title="我们需要准备的内容"></a>我们需要准备的内容</h2><ul><li>保证你可以连接到Unity.com官网，保证你有Unity账号。</li><li>保证你可以连接到Github官网，保证你有Github账号。</li><li>如果你有.edu邮箱，请准备好这个邮箱。</li><li>如果你没有.edu邮箱，请准备好一张你的学生证的照片，记得带<strong>本人照片</strong>以及<strong>日期</strong>。</li><li>上一条中，你也可以上<a href="https://www.chsi.com.cn/">学信网</a>去对学籍进行截图。</li></ul><h2 id="1-连接账号"><a href="#1-连接账号" class="headerlink" title="1. 连接账号"></a>1. 连接账号</h2><p>首先，打开<a href="https://github.com/">Github官网</a>，登录你的账号。</p><p>请你打开这个<a href="https://store.unity.com/academic/unity-student">网页</a>，并登录你的Unity账号。</p><p>在下方的How to access the Unity Student plan中，选择第一步的Authorize。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/2IhUo1MKbdNemzJ.png"></p><p>此时你会打开Github的授权界面，确定授权即可。</p><p>这一步主要是根据Unity的提示，给Unity授权获取你的一些Github的账号信息。</p><h2 id="2-申请Github学生认证"><a href="#2-申请Github学生认证" class="headerlink" title="2. 申请Github学生认证"></a>2. 申请Github学生认证</h2><p>如果你已经申请过Github的学生开发包（GitHub Student Developer Pack），请跳过这一步。</p><p>这一步是让Github确认我们的学生身份，我们准备的.edu邮箱或者学生证信息就是在这一步使用的。</p><p>请点击<a href="https://education.github.com/pack">这个连接</a>打开认证网页，你会看到这样的画面：<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/AOGQ4EhmqZxvJXz.png"></p><p>点击“Get the Pack”，会进入一个表单的填写。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/NbyfeMHtqOrIjg8.png"></p><p>在这个表单之中：</p><ul><li>选择Student。</li><li>添加你的.edu邮箱，这样认证速度最快。如果没有.edu邮箱，那么就选择你自己的私人邮箱。</li><li>选择你的学校名称（英文全称）。如果下拉列表里面没有你的学校名称，需要你手动填写，并额外填写学校的具体地址。</li><li>在没有edu邮箱的情况下，你还需要上传之前准备好的信息照片。<img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/4JrtZNo5zm1MDyY.png"></li><li>随便编一点你将要准备怎样使用Github。</li></ul><h3 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h3><p>在提交申请前，请一定<strong>不要挂梯子</strong>，当你点击提交，提交信息中有<strong>IP地址</strong>，这能判断你的地理位置。而Github会判断你的地理位置是否和你申请的学校位置相近！如果你挂了梯子（例如美国线路），而学校地址在国内，你的申请会被拒绝！！</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/Lzyq4tucrPJFC93.jpg"></p><p>（别问我是怎么知道的）</p><p>解决方法就是关闭梯子，或者挂上你学校的vpn访问Github，再进行提交。</p><p>接下来，等待4天左右，即可收到结果。结果会发送到你的邮箱之中，你也可以每天刷新这个申请表格：申请提交后网页右侧会有申请的状态。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/GoqbLBIc8jE5WdH.png"></p><h2 id="3-获取Unity-Pro激活码"><a href="#3-获取Unity-Pro激活码" class="headerlink" title="3. 获取Unity Pro激活码"></a>3. 获取Unity Pro激活码</h2><p>学生开发包申请成功后，请回到<a href="https://store.unity.com/academic/unity-student">Unity的认证</a>，点击第三个连接即可，你会在一瞬间收到Unity发给你的Unity Pro激活码。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/vDEqRTObrFZgGlL.png"></p><h2 id="4-Enjoy！"><a href="#4-Enjoy！" class="headerlink" title="4. Enjoy！"></a>4. Enjoy！</h2><p>整活吧！</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/SYTLt5U7NVicy8r.jpg"></p><h1 id="还有哪些东西？"><a href="#还有哪些东西？" class="headerlink" title="还有哪些东西？"></a>还有哪些东西？</h1><h2 id="AssetStore内的精品资源"><a href="#AssetStore内的精品资源" class="headerlink" title="AssetStore内的精品资源"></a>AssetStore内的精品资源</h2><p>Unity在后面两天还会给你发一个邮件，欢迎你来到Unity Student plan。<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/giqHfKtxpC8S69N.png"><br>这个邮件下方会有一个Unity Store的优惠码，可以免费获取价值400刀的精品资源。</p><h2 id="JetBrains-IDE"><a href="#JetBrains-IDE" class="headerlink" title="JetBrains IDE"></a>JetBrains IDE</h2><p>你可以通过Github学生开发包，获取一年的<a href="https://www.jetbrains.com/community/education/?authMethod=github#students">JetBrains全家桶</a>！</p><h2 id="一个免费域名！"><a href="#一个免费域名！" class="headerlink" title="一个免费域名！"></a>一个免费域名！</h2><p>通过Github学生开发包，在name.com获取一年的免费域名！</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/RgFEf3d5v7UHxDJ.jpg"></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>在<a href="https://education.github.com/pack">Github学生开发包网页</a>上获取更多内容！</p><h1 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h1><p>这个渠道我是从<a href="https://unity.cn/u/michael-wang-2/?tab=article">麦扣</a>的<a href="https://space.bilibili.com/370283072">B站</a>动态获取的，同时在Unity Connect也写有文章。但是奇怪的是，第二天这篇文章和动态就消失了。</p><p>麦扣的一些零基础入门Unity课程也很不错，大家可以去关注一下。</p><p>这里有热心网友的<a href="https://blog.csdn.net/weixin_43454101/article/details/106422959">备份</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]简单工厂模式、工厂方法模式和抽象工厂模式</title>
      <link href="2020/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单工厂模式（Simple-Factory-Pattern）"><a href="#简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="简单工厂模式（Simple Factory Pattern）"></a>简单工厂模式（Simple Factory Pattern）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>又称静态工厂方法（Static Factory Method）模式，属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt="简单工厂图解"></p><p>一共三个角色：</p><ul><li>工厂角色（Factory）：负责实现创建所有实例的内部逻辑；</li><li>抽象产品角色（Product）：具体对象的父类，负责描述所有实例共有的公共接口；</li><li>具体产品角色（ConcreteProduct）：最终的创建目标，所有创建的对象都充当这个角色某个具体类的实例。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>将对象的创建和对象本身业务处理分离，降低系统耦合度；</li><li>工厂方法是静态方法，使用起来很方便，可以直接通过类名调用，只需要传入一个简单的参数；</li><li>最大的问题在于对于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端免除直接创建产品对象的责任；</li><li>客户端只需要知道产品类的参数即可，减少使用者的对复杂类名的记忆量；</li><li>引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>工厂类集中了所有产品创建逻辑，一旦不能工作，整个系统都要受到影响；</li><li>使用简单工厂模式会增加系统中的类的个数，</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，不利于系统的扩展与维护；</li><li>由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h2 id="我该什么时候使用？"><a href="#我该什么时候使用？" class="headerlink" title="我该什么时候使用？"></a>我该什么时候使用？</h2><ul><li>工厂类负责创建的对象比较少；</li><li>客户端只知道传入工厂类的参数，对如何创建对象不关心，只需要知道类型对应参数。</li></ul><h1 id="工厂方法模式（Factory-Method-Pattern）"><a href="#工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="工厂方法模式（Factory Method Pattern）"></a>工厂方法模式（Factory Method Pattern）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>又称为工厂模式，也叫虚拟构造器（Virtual Constructor）模式或多态工厂（Polymorphic Factory）模式，属于类创造型模式。</p><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。</p><p>将产品类的实例化操作延迟到工厂子类中完成。</p><h2 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="工厂方法"></p><p>一共四个角色：</p><ul><li>Product：抽象产品</li><li>ConcreteProduct：具体产品</li><li>Factory：抽象工厂</li><li>ConcreteFactory：具体工厂</li></ul><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>是简单工厂的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，克服了他的缺点。</p><p>所有产品的创建交给了子类去做，核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化。</p><p>使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FcTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Factory fc = <span class="keyword">new</span> ConcerteFactory(); <span class="comment">// 选择工厂</span></span><br><span class="line">    Product prod = fc.factoryMethod();  <span class="comment">// 创建产品-</span></span><br><span class="line">    prod.use();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体类将被实例化这一细节。只需要知道产品所需的工厂继续ing；</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。所有具体工厂类都具有同一个抽象父类；</li><li>系统加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品。只需要添加一个具体工厂和具体产品就可以了。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每新增一个产品，就要编写新的具体产品类，还要提供对应的具体工厂类。系统中类的个数成对增加；</li><li>客户端代码需要使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能用到DOM、反射等技术，增加了实现难度。</li></ul><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂；</li><li>一个类通过其子类来指定创建哪个对象；</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul><h1 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>又称Kit模式，属于对象创建型模式。</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h2 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt="抽象工厂"></p><p>包含如下4个角色：</p><ul><li>AbstractFactory：抽象工厂</li><li>ConcreteFactory：具体工厂</li><li>AbstractProduct：抽象产品</li><li>Product：具体产品</li></ul><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>引入了两个概念：</p><ul><li>产品等级结构：即产品的继承结构；</li><li>产品族：同一工厂生产的，位于不同产品等级结构中的一组产品。</li></ul><p>抽象工厂模式面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。</p><p>例如：</p><ul><li>海尔电器工厂生产：海尔电视机、海尔电冰箱等。</li><li>其中，海尔电器工厂就是一个具体工厂，它生产的电视机、电冰箱就是海尔产品族。</li><li>而海尔电视机属于电视机的产品等级结构，电视机这一抽象产品下还会有海信电视机、索尼电视机等。</li></ul><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不知道什么被创建。可以实现高内聚低耦合的设计目的。</li><li>当一个产品族中多个对象一起工作时，抽象工厂模式能够保证客户端始终只使用一个产品族中的对象。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://www.cnblogs.com/fws94/p/7490305.html">【Unity与23种设计模式】抽象工厂模式（Abstract Factory）</a><br><a href="https://www.cnblogs.com/Jason-c/p/8796449.html">Unity C# 设计模式（四）抽象工厂模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[笔记]洗牌算法</title>
      <link href="2020/03/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
      <url>2020/03/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何实现随机性？"><a href="#如何实现随机性？" class="headerlink" title="如何实现随机性？"></a>如何实现随机性？</h1><p>一个简单的题目：<strong>有一个大小为100的数组，里面的元素是从 1 到 100，怎样随机从里面选择 1 个数呢？</strong></p><p>在Unity中的实现很简单：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetRandomNum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Random.Range(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：在Unity中，<code>Random.Range()</code>方法有两个不同的实现：</p><p><code>public static float Range(float min, float max);</code> 包含min与max.</p><p><code>public static int Range(int min, int max);</code> 不包含max，如果min与max相等，返回min。</p><h1 id="不重复的50个数"><a href="#不重复的50个数" class="headerlink" title="不重复的50个数"></a>不重复的50个数</h1><p>题目难度增加：<strong>有一个大小为100的数组，里面的元素是从 1 到 100，怎样随机从里面选择不重复的50个数呢？。</strong></p><p>如果我们随机50次也不能保证50个数字都是不重复的。</p><p>如果我们将随机的数放到数组里，去判断有没有这个数，是不是就可以解决了呢？有一说一，确实能完成题目要求，但是考虑极限就会发现越往后取数字，重复概率越高，需要重复随机的次数也就越多，我们在Unity中用取100个数来试一下：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; Found = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Found.Count &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> rNum = Random.Range(<span class="number">0</span>, <span class="number">101</span>);</span><br><span class="line">        <span class="built_in">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (Found.ContainsKey(rNum))</span><br><span class="line">        &#123;</span><br><span class="line">            rNum = Random.Range(<span class="number">0</span>, <span class="number">101</span>);</span><br><span class="line">            Debug.Log(Found.Count + <span class="string">&quot;: Time:&quot;</span> + time);</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        Found.Add(rNum, rNum);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Added: &quot;</span> + Found.Count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出前几个是这个样子的：<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/cSIwAsNnxJ6QdT4.png" alt="20200325165706"><br>而后几个是这样的：<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/D91q65l8y2tgSYX.png" alt="20200325165736"></p><p>可以看到在最后几个数字的随机中，都重复了九十多次。越到最后一个，拿到没出现过的随机数越难，重复越多。</p><h1 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h1><p>我们可以对选出数的数组做点事情，让一个数出现在任意位置的概率事相同的。</p><h2 id="Fisher–Yates-Shuffle算法"><a href="#Fisher–Yates-Shuffle算法" class="headerlink" title="Fisher–Yates Shuffle算法"></a>Fisher–Yates Shuffle算法</h2><p>思路是随机取索引值，每次从剩下的数字中随机取一个：</p><ol><li>从还没处理的数组（假如还剩k个）中，随机产生一个[0, k]之间的数字p（假设数组从0开始）；</li><li>从剩下的k个数中把第p个数取出；</li><li>重复步骤2和3直到数字全部取完；</li><li>从步骤3取出的数字序列便是一个打乱了的数列。</li></ol><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShuffleFisherYates</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; copy = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(arr);</span><br><span class="line">    <span class="built_in">int</span> len = copy.Count;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> index = Random.Range(<span class="number">0</span>, len);</span><br><span class="line">        <span class="built_in">int</span> pick = copy[index];</span><br><span class="line">        copy.RemoveAt(index);</span><br><span class="line">        arr[len - <span class="number">1</span>] = pick;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法开辟了一个新的空间用来复制数组。Random类是UnityEngine内的实现。</p><h2 id="Knuth-Durstenfeld-Shuffle算法"><a href="#Knuth-Durstenfeld-Shuffle算法" class="headerlink" title="Knuth-Durstenfeld Shuffle算法"></a>Knuth-Durstenfeld Shuffle算法</h2><p>是Knuth和Durstenfeld在FIsher等人的基础上对算法进行了改进。</p><p>每次从未处理的数据中随机取出一个数组，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。这是一个原地算法。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShuffleKnuthDurstenfeld</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = Random.Range(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[index];</span><br><span class="line">            arr[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Random类是UnityEngine内的实现。</p><h2 id="Inside-Out-Algorithm"><a href="#Inside-Out-Algorithm" class="headerlink" title="Inside-Out Algorithm"></a>Inside-Out Algorithm</h2><p>有些应用中可能需要保留原始数据，因此开辟一个新数组来存储打乱后的序列。</p><p>Inside-Out Algorithm 算法的基本思想是设一游标i从前向后扫描原始数据的拷贝，在[0, i]之间随机一个下标j，然后用位置j的元素替换掉位置i的数字，再用原始数据位置i的元素替换掉拷贝数据位置j的元素。其作用相当于在拷贝数据中交换i与j位置处的值。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">ShuffleInsideOut</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> j = Random.Range(<span class="number">0</span>, i);</span><br><span class="line">        res[i] = res[j];</span><br><span class="line">        res[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.ToArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Random类是UnityEngine内的实现。</p><h1 id="洗牌算法最佳实践"><a href="#洗牌算法最佳实践" class="headerlink" title="洗牌算法最佳实践"></a>洗牌算法最佳实践</h1><p>使用这个工具类即可：</p><p>这里用的是System里面的Random类，比较通用。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shuffle</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IList&lt;T&gt; list</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.Random r = <span class="keyword">new</span> System.Random();</span><br><span class="line">    <span class="built_in">int</span> n = list.Count;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="built_in">int</span> k = r.Next(n + <span class="number">1</span>);</span><br><span class="line">        T temp = list[k];</span><br><span class="line">        list[k] = list[n];</span><br><span class="line">        list[n] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]单例模式</title>
      <link href="2020/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式（Singleton Pattern）确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：</p><ul><li>某个类只能有一个实例；</li><li>这个类必须自行创建这个实例；</li><li>这个类必须自行向整个系统提供这个实例。</li></ul><p>单例模式又名单件模式或者单态模式。</p><h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/y98PFCLlajG5ErS.png" alt="单例模式图解"></p><h1 id="我应该何时用它？"><a href="#我应该何时用它？" class="headerlink" title="我应该何时用它？"></a>我应该何时用它？</h1><p>判断是否使用单例模式，你需要确定：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="饿汉式——静态初始化"><a href="#饿汉式——静态初始化" class="headerlink" title="饿汉式——静态初始化"></a>饿汉式——静态初始化</h2><p>创建流程：</p><ol><li>创建静态的私有变量，并实例化（在第一次引用类的任何成员时创建实例）。</li><li>私有化构造函数（不能外部new出来）。</li><li>创建全局的唯一访问点。</li></ol><p>代码实现：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomethingFunction</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">  Singleton.Instance.DoSomethingFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式——多线程中的双重锁定"><a href="#懒汉式——多线程中的双重锁定" class="headerlink" title="懒汉式——多线程中的双重锁定"></a>懒汉式——多线程中的双重锁定</h2><p>懒汉式单例是在第一次使用时创建，可以延时加载，等待用户调用静态方法时才创建对象。</p><p>一个普通的懒汉式单例：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">  <span class="comment">// 构造函数私有，不能被外部直接调用</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 通过属性提供实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(_instance == <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在高并发、多线程环境下实现懒汉式单例，某一时刻可能会有多个线程需要使用单例对象，可能会造成创建多个实例对象，这违背单例模式的设计意图。</p><p>因此我们可以进行加锁，两次判断：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">  <span class="comment">// 🔒</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> syn = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  <span class="comment">// 构造函数私有，不能被外部直接调用</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 通过属性提供实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(_instance == <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">lock</span>(syn) <span class="comment">// 加锁，防止多线程访问</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(_instance == <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个还是有缺点的，虽然对方法进行了同步，解决了多线程的访问不安全性，但是每次访问Instance属性都会去判断锁的状态，比较耗时。</p><p>因此我们还有内部类的方法：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造函数私有，不能被外部直接调用</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 通过属性提供实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> SingletonHolder._instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在静态内部类中，实现延时加载</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SingletonHolder</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样既保证了线程安全，又能够延迟加载。</p><p>具体为什么在内部类中进行实例化就能够保证延迟加载且线程安全呢？可以看<a href="https://blog.csdn.net/abc524061/article/details/57086267">这篇文章</a>和<a href="https://blog.csdn.net/nsw911439370/article/details/50456231">这篇文章</a>。</p><p>相关资料还可以看<a href="http://www.360doc.com/content/17/0331/14/6432946_641696566.shtml">这篇文章</a>。</p><h2 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h2><p>饿汉式单例类在类被加载时就将自己实例化，特点在于：</p><ul><li>无需考虑多线程访问问题，可以确保实例的唯一性。</li><li>从调用速度和反应时间角度来讲，饿汉式优于懒汉式。</li><li>从资源利用的角度来讲，不管系统运行时是否使用该单例对象，饿汉式都要创建，这一点不如懒汉式。</li></ul><br/><p>而懒汉式单例在第一次使用时创建，无须一直占用系统资源，特点在于：</p><ul><li>实现了延迟加载。</li><li>必须处理好多个线程同时访问的问题，特别作为资源管理器的时候。</li><li>需要通过多重检查锁定机制控制，导致系统性能受到一定影响。</li></ul><h1 id="不要过度使用！"><a href="#不要过度使用！" class="headerlink" title="不要过度使用！"></a>不要过度使用！</h1><p>想要用好单例，最重要的是想怎么样用少单例，越少越好。</p><p>单例是通常是全生命周期永不销毁的，所以承担的也是全局功能。如果你做的不是全局功能，你本来就不应该用单例。局部功能必定有入口和出口以及自己的生命周期，你就应该把需要的东西放自己身上，随自己销毁，而不是单例出去。</p><h2 id="不得不用单例的场景"><a href="#不得不用单例的场景" class="headerlink" title="不得不用单例的场景"></a>不得不用单例的场景</h2><ul><li>各种辅助函数，全局的不带状态信息的工具类等。</li><li>配表数据，数据直接转成代码或者静态数据，没有并发问题。</li></ul><h2 id="使用单例更方便的场景"><a href="#使用单例更方便的场景" class="headerlink" title="使用单例更方便的场景"></a>使用单例更方便的场景</h2><ul><li>类似于AssetBundle管理器（资源管理器）、音乐音效管理器这种，属于一定在周期内调用，且不影响Gameplay的情景。</li><li>全局状态管理，管理游戏整体流程的。</li><li>类似于Debug这个类，Uniy帮你进行了制作，直接用很方便。</li></ul><h2 id="不建议用单例的场景"><a href="#不建议用单例的场景" class="headerlink" title="不建议用单例的场景"></a>不建议用单例的场景</h2><ul><li>游戏内支持一些比较特殊的功能时，例如重放（说的就是你命令模式）、热更新、断线重连等。这个情况相当于通过一个逻辑线程来驱动整个游戏逻辑。</li><li>单例之间总会产生依赖，这会导致你需要人肉维护一坨坨代码。新增加单例后顺序可能会乱掉，逻辑会爆掉。</li></ul><h1 id="在Unity中实现的泛型单例模板"><a href="#在Unity中实现的泛型单例模板" class="headerlink" title="在Unity中实现的泛型单例模板"></a>在Unity中实现的泛型单例模板</h1><p>在Unity中，很多游戏管理类都是唯一的，用一个GameObject游戏物体运行就行了，那么我们这里有一个单例模板，哪个类需要用单例类，去继承这个单例类就行了：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> T _instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> _lock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (applicationIsQuitting)  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">lock</span>(_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          _instance = (T) FindObjectOfType(<span class="keyword">typeof</span>(T));</span><br><span class="line">          <span class="keyword">if</span> ( FindObjectsOfType(<span class="keyword">typeof</span>(T)).Length &gt; <span class="number">1</span> )  <span class="keyword">return</span> _instance;</span><br><span class="line">          <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            GameObject singleton = <span class="keyword">new</span> GameObject();</span><br><span class="line">            _instance = singleton.AddComponent&lt;T&gt;();</span><br><span class="line">            singleton.name = <span class="string">&quot;(Singleton) &quot;</span>+ <span class="keyword">typeof</span>(T).ToString();</span><br><span class="line">            DontDestroyOnLoad(singleton);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> applicationIsQuitting = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDestroy</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    applicationIsQuitting = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类实现了多线程锁机制，能够保证数据安全。如果场景中没有该类，就会自动创建一个“（Singleton）类名”的游戏物体，一旦创建，切换场景也不会销毁。</p><p>这一段泛型模板摘自<a href="https://blog.csdn.net/honey199396/article/details/48827955">unity3D – 单例泛型模板</a></p><p>另一版也可以使用：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">public abstract class Singleton&lt;T&gt; where T : new()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> T _instance;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">object</span> _lock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_lock)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            _instance = <span class="keyword">new</span> T();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Unity生命周期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonoSingleton</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> T _instance;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        _instance = FindObjectOfType(<span class="keyword">typeof</span>(T)) <span class="keyword">as</span> T;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">          obj.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">          _instance = (T)obj.AddComponent(<span class="keyword">typeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Destroy(gameObject); ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]命令模式</title>
      <link href="2020/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>命令模式属于对象的行为型模式。命令模式是把一个操作或者行为抽象为一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。</p><h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p><img src="https://i.loli.net/2020/03/22/JuOYSDj98KNILEF.png" alt="命令模式图解"></p><p>命令模式的结构图涉及到五个角色：</p><ul><li>客户（Client）：发出一个具体的命令并确定其接收者。</li><li>命令（Command）：声明了一个用于给具体命令类实现的抽象接口。</li><li>具体命令（ConcreteCommand）：定义了一个接收者和行为的弱耦合，负责调用接受者的相应方法。</li><li>请求者（Invoker）：负责调用命令对象执行命令。</li><li>接受者（Receiver）：具体行为的执行。</li></ul><h1 id="命令模式能用到哪？"><a href="#命令模式能用到哪？" class="headerlink" title="命令模式能用到哪？"></a>命令模式能用到哪？</h1><p>想要制作游戏中类似于守望先锋回访系统的“时间回溯”功能，通过<del>卖萌</del>询问群友得知有“命令模式”这么个神奇的存在。</p><p><img src="https://i.loli.net/2020/03/21/srQ2vlCeFfKgM65.png" alt="DVA真可爱"></p><p>利用命令模式这样的程序设计，可以实现诸如撤销，重做，回访，时间倒流之类的功能。</p><p>可以参考《Dota2》中的观战系统、《魔兽争霸3》中的录像系统等。</p><!-- https://blog.csdn.net/poem_qianmo/article/details/52663057 --><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="联想到了什么？"><a href="#联想到了什么？" class="headerlink" title="联想到了什么？"></a>联想到了什么？</h2><p>我们在介绍InputSystem时提到过，InputSystem想要提供一个平台，统一管理不同外设的输入，通过Action调用，这里面实际上就蕴含了命令模式的思想。</p><a href="#">Post not found: Unity-InputSystem输入系统初探 设Unity-InputSystem输入系统初探</a><h2 id="我想出门吃好的"><a href="#我想出门吃好的" class="headerlink" title="我想出门吃好的"></a>我想出门吃好的</h2><p>我们举一个例子，来实现一个命令模式：</p><blockquote><p>客户进入餐厅进行点餐，点餐流程为：</p><ol><li>客户进行点餐，填写订单；</li><li>服务员将订单放到订单柜台，并通知厨师；</li><li>厨师根据订单制作餐点。</li></ol></blockquote><p>在这个例子中，一张订单封装了准备餐点的请求，把订单想象成一个用来请求准备餐点的对象，订单对象可以被传递；服务员传递订单到柜台，然后通知厨师订单来了。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>具体实现是什么样子的呢？</p><p>在这个例子中，各角色分别为：</p><ol><li>餐厅是客户（Client）角色，提供点餐功能；</li><li>服务员是请求者（Invoker）角色，用以传递订单；</li><li>没填写的订单就是命令（Command）角色；</li><li>填写好的订单是具体命令（ConcreteCommand）角色；</li><li>厨师是最后的接受者（Receiver）。</li></ol><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chef</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cook</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Printf(<span class="string">&quot;做菜！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IOrder</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>; <span class="comment">// 调用做菜</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Undo</span>(<span class="params"></span>)</span>;  <span class="comment">// 撤销</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做具体的菜，比如我要吃西红柿炒鸡蛋</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TomatoOmeletteOrder</span> : <span class="title">IOrder</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Chef chef;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TomatoOmeletteOrder</span>(<span class="params">Chef chef</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">this</span>.chef = chef;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    chef.Cook();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务员让厨师做菜</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Waiter</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> IOrder order;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOrder</span>(<span class="params">IOrder order</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">this</span>.order = order;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下单</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeOrder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    order.Execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户使用（客户在客户端中使用）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainClient</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="comment">// 餐厅里有服务员和厨师</span></span><br><span class="line">    Waiter waiter = <span class="keyword">new</span> Waiter();</span><br><span class="line">    Chif chif = <span class="keyword">new</span> Chif();</span><br><span class="line">    <span class="comment">// 客人具体点了西红柿炒鸡蛋</span></span><br><span class="line">    TomatoOmeletteOrder tOrder = <span class="keyword">new</span> TomatoOmeletteOrder(chif);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务员给客人下单</span></span><br><span class="line">    waiter.SetOrder(tOrder);</span><br><span class="line">    waiter.TakeOrder(); <span class="comment">// 最终通过厨师做好了菜</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="更多用途"><a href="#更多用途" class="headerlink" title="更多用途"></a>更多用途</h2><ul><li>队列请求（命令队列）</li><li>日志记录</li><li>撤销之前的操作</li></ul><h2 id="命令模式的优缺点"><a href="#命令模式的优缺点" class="headerlink" title="命令模式的优缺点"></a>命令模式的优缺点</h2><p>优点：</p><ul><li>解耦，将发起命令的客户端与具体处理命令的接收者完全解耦，客户端不知道接收者是什么样子。</li><li>动态控制，把请求封装，可以动态对请求进行参数化、队列化和日志化等。</li><li>很容易的实现复合命令功能。</li><li>更好的扩展，很容易添加新命令。</li></ul><p>缺点：类的数量会随着命令数量的增长而增长，可能造成类数量过多。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]UML类图和类之间的关系</title>
      <link href="2020/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>2020/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="例图"><a href="#例图" class="headerlink" title="例图"></a>例图</h1><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/uml_class_struct.jpg" alt="类图"></p><h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><h2 id="泛化关系（generalization）"><a href="#泛化关系（generalization）" class="headerlink" title="泛化关系（generalization）"></a>泛化关系（generalization）</h2><blockquote><p>例图中的“小汽车”和“SUV”的关系</p></blockquote><p>泛化关系实际上就是类的继承结构，两个对象之间如果可以用“A是B”，就可以说A和B是继承关系。</p><p>例如：自行车是车、猫是动物。</p><p>泛化关系用带空心箭头的实线连接，A指向B即为A继承自B。</p><p>在代码中，泛化关系表现为继承非抽象类：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 汽车类</span></span><br><span class="line">  <span class="comment">// 汽车是“车”这一概念的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SUV</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// SUV是汽车</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现关系（realization）"><a href="#实现关系（realization）" class="headerlink" title="实现关系（realization）"></a>实现关系（realization）</h2><blockquote><p>例图中“车”与“小汽车”或与“自行车”的关系</p></blockquote><p>实现关系用带空心箭头虚线连接，A指向B即为A是B的实现。</p><p>在代码中，实现关系表现为继承抽象类：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 车的抽象类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 汽车类实现了车</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bike</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 自行车类实现了车</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h2><blockquote><p>类图中“学生”和“班级”之间的关系</p></blockquote><p>聚合关系用一条带空心菱形箭头的直线表示，A指向B称为A聚合到B上，或者说B由A组成。</p><p>聚合关系是实体对象之间的关系，是一个整体由多个部分构成。</p><p>整体和部分不是强依赖的，也就是说即使整体不存在了，部分依然存在：班级解散了，学生不会消失，他们还会存在。</p><h2 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h2><blockquote><p>类图中“小汽车”和“轮胎”或“发动机”之间的关系</p></blockquote><p>组合关系用一条带实心菱形箭头直线表示，A指向B称为A组成B，或者B由A组成。</p><p>类比聚合关系。</p><p>组合关系是强依赖的特殊聚合关系，整体不存在了，部分也不存在了。例如公司不存在了，公司的部门也不存在了。</p><h2 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h2><blockquote><p>类图中“学生”和“身份证”之间的关系</p></blockquote><p>关联关系用带箭头的实线表示，一般不强调方向。强调方向的例如A指向B，那就表示A知道B，但B不知道A。</p><p>这是一种静态关系，一般与运行状态无关，一般由常识等因素决定。一般来定义对象之间静态的、天然的结构。是强关联的关系。</p><p>例如乘车人和车票，学生和学校。</p><p>代码实现中，关联对象通常以成员变量的形式实现的：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> IDCard idCard; <span class="comment">// 学生有身份证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h2><p>带箭头的虚线表示，A指向B代表A依赖于B。即A运行期间会用到B。</p><p>这个依赖关系是一种临时性的关系，在运行期间产生，在运行时依赖关系也可能会改变。</p><p>依赖是有方向的，且双向依赖<strong>非常糟糕</strong>，我们应该保持单项依赖，杜绝双向依赖。</p><p>代码实现中，依赖关系体现为类构造方法以及类方法的传入参数，箭头的指向为调用关系。依赖关系的含义除了“临时知道”之外，还有“使用”对方的方法或属性。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Read</span>(<span class="params">Book book</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    printf(book.Title);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Title&#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity]InputSystem输入系统初探</title>
      <link href="2020/03/14/Unity/Unity-InputSystem%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2/"/>
      <url>2020/03/14/Unity/Unity-InputSystem%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是Input-System？"><a href="#什么是Input-System？" class="headerlink" title="什么是Input System？"></a>什么是Input System？</h1><p>Input System是Unity 2019版本中新加入的一个输入系统，旨在成为经典的Input类的替代品。</p><p>创建Input Syetem的宗旨是提供一个平台，统一管理不同外设的输入。开发者进行开发时，不用再去烦恼输入设备的种类，只用去管哪种类型的Action就行了。可以参考VRTK这个为VR设备提供的输入输出平台。</p><h1 id="如何安装Input-System？"><a href="#如何安装Input-System？" class="headerlink" title="如何安装Input System？"></a>如何安装Input System？</h1><blockquote><p>注意：新的输入系统需要Unity2019.1以上和.NET4运行时。旧版.NET3.5运行时的项目中不起作用。</p></blockquote><h2 id="通过包管理器安装"><a href="#通过包管理器安装" class="headerlink" title="通过包管理器安装"></a>通过包管理器安装</h2><p>新输入系统通过包管理器(Package Manager)进行安装，需要勾选“Advanced”中的“Show Preview Packages”选项。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/Images/ShowPreviewPackages.png" alt="勾选高级选项"></p><p>找到Input System后安装即可。</p><h2 id="在Player-Settings中开启"><a href="#在Player-Settings中开启" class="headerlink" title="在Player Settings中开启"></a>在Player Settings中开启</h2><p>在Unity中创建项目后，默认使用经典输入方式。我们需要将“Active Input Handling”项调整为新输入系统，并<strong>重启编辑器</strong>。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/Images/ActiveInputHandling.png" alt="调整新输入系统"></p><p>当然可以选择Both，同时启用传统输入和新的输入系统。</p><h1 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h1><h2 id="直接从设备获取输入"><a href="#直接从设备获取输入" class="headerlink" title="直接从设备获取输入"></a>直接从设备获取输入</h2><p>直接搬过来文档的代码</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlayerScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> gamepad = Gamepad.current;</span><br><span class="line">        <span class="keyword">if</span> (gamepad == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// No gamepad connected.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gamepad.rightTrigger.wasPressedThisFrame)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &#x27;Use&#x27; code here</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector2 move = gamepad.leftStick.ReadValue();</span><br><span class="line">        <span class="comment">// &#x27;Move&#x27; code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，可以通过UnityEngine.InputSystem这个命名空间里面的对应输入设备的类获取输入，比如Keyboard.current或者Mouse.current。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> keyboard = Keyboard.current;</span><br><span class="line">  <span class="keyword">if</span> (keyboard == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (keyboard.anyKey)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法还是有弊端的，针对不同设备，需要不同的API来调用。</p><h2 id="通过InputAction获取输入"><a href="#通过InputAction获取输入" class="headerlink" title="通过InputAction获取输入"></a>通过InputAction获取输入</h2><h3 id="添加Player-Input组件"><a href="#添加Player-Input组件" class="headerlink" title="添加Player Input组件"></a>添加Player Input组件</h3><p>通过Input Action作为中介来控制输入和响应更加合理，官方在这里给出的是使用“PlayerInput”组件来控制输入。</p><h3 id="创建Input-Action-Asset"><a href="#创建Input-Action-Asset" class="headerlink" title="创建Input Action Asset"></a>创建Input Action Asset</h3><p>这里Player Input引导我们创建一个“Input Action Asset”，这个文件可以看作是Input Action的定义文件。（文件后缀名为.inputactions）</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/Images/PlayerInputCreateActions.png" alt="创建Input Action Asset"></p><p>在弹出的窗口中我们就可以针对不同的Action为不同的设备定义按键了。</p><p><img src="https://i.loli.net/2020/03/15/rNvK1fFlgGCX2De.png"></p><h3 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h3><p>通过Player Input组件我们可以在Inspector窗口中创建Unity中常用的回调，比如直接发送信息，广播信息，调用Unity事件，调用C#事件：</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/Images/PlayerInputNotificationBehaviors.png" alt="创建回调"></p><p>选Invoke Unity Event这个就可以看到<del>我这个萌新比较熟悉的</del>事件调用的列表了，之后就可以开心的拖拖拽拽了！</p><blockquote><p>注意：需要获取输入数值时（比如摇杆的Vector2数据），需要定义动态回调方法，参数里面要有一个“CallbackContext”类的参数，这个里面有相关Action的数据。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/Images/MyPlayerActionEvents.png" alt="注意调用"></p></blockquote> <figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlayerScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       Debug.Log(<span class="string">&quot;Fire!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这部分内容设置输入和回调都是基于Player Input组件的，对比较复杂的输入方式，用这个组件的功能可能会让人感到麻烦。实际上还有其他方式来整理Input Action：</p><p><img src="https://i.loli.net/2020/03/15/3q2GRdUMNfJLDoQ.png"></p><p>更多内容随后整理。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://www.bilibili.com/read/cv2938602">Unity新输入方案InputSystem介绍-序</a></li><li><a href="https://blog.csdn.net/u010019717/article/details/86358975">【Unity3d】新输入系统New InputSystem 0.1.2版本简介</a></li><li><a href="https://github.com/Unity-Technologies/InputSystem">Unity-Technologies/InputSystem</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 输入系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[笔记]初级算法-数组问题总结Ⅱ</title>
      <link href="2020/03/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E2%85%A1/"/>
      <url>2020/03/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><blockquote><p>输入: [1,2,3]</p><p>输出: [1,2,4]</p><p>解释: 输入数组表示数字 123。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,3,2,1]</p><p>输出: [4,3,2,2]</p><p>解释: 输入数组表示数字 4321。</p></blockquote><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 倒序加1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">PlusOne</span>(<span class="params"><span class="built_in">int</span>[] digits</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> len = digits.Length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="built_in">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><blockquote><p>输入: [0,1,0,3,12]</p><p>输出: [1,3,12,0,0]</p></blockquote><p>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 置零</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveZeroes</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>, lastZero = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[lastZero] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i != lastZero) </span><br><span class="line">                &#123;</span><br><span class="line">                  nums[i] = <span class="number">0</span>;</span><br><span class="line">                  lastZero++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/QHgTMmwJhfK6GV3.gif" alt="置零"></p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="comment">// 把遇到的所有不非零的向前放</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveZeroes</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[zero] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[zero];</span><br><span class="line">                nums[zero] = temp;</span><br><span class="line">                zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/YKbQMzif2DseWUg.gif" alt="交换"></p><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p></blockquote><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力法，遍历搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> find = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; nums.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == find)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表（对于key是int型的,用Dictionary速度更快）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">        Hashtable h = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> find = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(h.ContainsKey(find))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123; (<span class="built_in">int</span>)h[find], i&#125;;</span><br><span class="line">            h[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> find = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dic.ContainsKey(find))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;dic[find], i&#125;;</span><br><span class="line">            <span class="comment">// 注意这里要先判断是否已经存在同样的键</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!dic.ContainsKey(nums[i]))</span><br><span class="line">                    dic.Add(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><ol><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li></ol><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/250px-Sudoku-by-L2G-20050714.svg.png" alt="数独图"></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>示例 1:</p><p>输入:</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>输出: false</p><p>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。</p><p>但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p></blockquote><p>说明:</p><p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsValidSudoku</span>(<span class="params"><span class="built_in">char</span>[][] board</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (board==<span class="literal">null</span> || board.Length==<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;[] row = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;[<span class="number">9</span>];<span class="comment">//行</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;[] col = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;[<span class="number">9</span>];<span class="comment">//列</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;[] box = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;[<span class="number">9</span>];<span class="comment">//宫</span></span><br><span class="line">        <span class="comment">//初始化哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            row[i] = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">            col[i] = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">            box[i] = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前没有字符 抬走 下一个</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j].Equals(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算宫的索引</span></span><br><span class="line">                <span class="built_in">int</span> k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="comment">//当前元素对应的行集合,列集合,宫集合,都不重复</span></span><br><span class="line">                <span class="keyword">if</span> (!row[i].ContainsKey(board[i][j]) &amp;&amp; !col[j].ContainsKey(board[i][j]) &amp;&amp; !box[k].ContainsKey(board[i][j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    row[i].Add(board[i][j],i);</span><br><span class="line">                    col[j].Add(board[i][j],j);</span><br><span class="line">                    box[k].Add(board[i][j],k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rotate</span>(<span class="params"><span class="built_in">int</span>[][] matrix</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[笔记]初级算法-数组问题总结</title>
      <link href="2020/03/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>2020/03/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><blockquote><p>给定数组 nums = [1,1,2],</p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p></blockquote><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// nums 是以”引用”方式传递的。也就是说，不对实参做任何拷贝</p><p>int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。</p><p>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</p><p>  for (int i = 0; i &lt; len; i++) {</p><p>  print(nums[i]);</p><p>}</p></blockquote><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RemoveDuplicates</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.Length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机Ⅱ"><a href="#买卖股票的最佳时机Ⅱ" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><blockquote><p>输入: [7,1,5,3,6,4]</p></blockquote><blockquote><p>输出: 7</p></blockquote><blockquote><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p><p>随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [1,2,3,4,5]</p><p>输出: 4</p><p>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p><p>注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</p><p>因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p></blockquote><p>示例 3:</p><blockquote><p>输入: [7,6,4,3,1]</p><p>输出: 0</p><p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxProfit</span>(<span class="params"><span class="built_in">int</span>[] prices</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">int</span> buy = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; prices.Length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == buy) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>( prices[i] &lt; prices[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                buy = i;</span><br><span class="line">                res += prices[i + <span class="number">1</span>] - prices[buy];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p>旋转数组</p><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><blockquote><p>输入: [1,2,3,4,5,6,7] 和 k = 3</p><p>输出: [5,6,7,1,2,3,4]</p><p>解释:</p><p>向右旋转 1 步: [7,1,2,3,4,5,6]</p><p>向右旋转 2 步: [6,7,1,2,3,4,5]</p><p>向右旋转 3 步: [5,6,7,1,2,3,4]</p></blockquote><p>示例 2:</p><blockquote><p>输入: [-1,-100,3,99] 和 k = 2</p><p>输出: [3,99,-1,-100]</p><p>解释: </p><p>向右旋转 1 步: [99,-1,-100,3]</p><p>向右旋转 2 步: [3,99,-1,-100]</p></blockquote><p>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</p><p>要求使用空间复杂度为 O(1) 的 原地 算法。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rotate</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp, previous;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            previous = nums[nums.Length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; nums.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用新数组拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rotate</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[nums.Length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[(i + k) % nums.Length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三次旋转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rotate</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        k %= nums.Length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.Length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.Length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> start, <span class="built_in">int</span> end</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="存在重复"><a href="#存在重复" class="headerlink" title="存在重复"></a>存在重复</h1><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>示例 1:</p><blockquote><p>输入: [1,2,3,1]</p><p>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: [1,2,3,4]</p><p>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: [1,1,1,3,3,4,3,2,4,2]</p><p>输出: true</p></blockquote><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ContainsDuplicate</span>(<span class="params"><span class="built_in">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.Length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Hashtable h = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h.ContainsKey(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> h.Add(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 朴素（超时）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ContainsDuplicate</span>(<span class="params"><span class="built_in">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">                <span class="keyword">if</span> (nums[j] == nums[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]</p><p>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,1,2,1,2]</p><p>输出: 4</p></blockquote><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希集：HashSet只接受不重复的集合(占用了额外空间)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">SingleNumber</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        HashSet&lt;<span class="built_in">int</span>&gt; s = <span class="keyword">new</span> HashSet&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.Add(nums[i]))</span><br><span class="line">                s.Remove(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.First();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑方法：按位异或（xor）</span></span><br><span class="line"><span class="comment">// 1. 当一个数与0进行按位异或操作时，所得的为该值</span></span><br><span class="line"><span class="comment">// 2. 当相同的两个值进行异或时，所得为0</span></span><br><span class="line"><span class="comment">// 3. 因此，数组遍历时，result的值会在nums[i]和0之间变化</span></span><br><span class="line"><span class="comment">// 4. 两个相同的数经过这个过程后，会抵消。而只有一个的会被保留下来（即1）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">SingleNumber</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两个数组的交集Ⅱ"><a href="#两个数组的交集Ⅱ" class="headerlink" title="两个数组的交集Ⅱ"></a>两个数组的交集Ⅱ</h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1:</p><blockquote><p>输入: nums1 = [1,2,2,1], nums2 = [2,2]</p><p>输出: [2,2]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</p><p>输出: [4,9]</p></blockquote><p>说明：</p><p>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</p><p>我们可以不考虑输出结果的顺序。</p><p>进阶:</p><ul><li><p>如果给定的数组已经排好序呢？你将如何优化你的算法？</p></li><li><p>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</p></li><li><p>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p></li></ul><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先排序，后遍历，双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">Intersect</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Array.Sort(nums1);</span><br><span class="line">        Array.Sort(nums2);</span><br><span class="line">        <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.Length &amp;&amp; j &lt; nums2.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res.Add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表做法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">Intersect</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2</span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="literal">null</span> || nums2 == <span class="literal">null</span> || nums1.Length == <span class="number">0</span> || nums2.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接将nums1调整为小数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums2.Length &lt; nums1.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存下nums1所有不重复的元素，并记录出现次数</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums1.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dic.ContainsKey(nums1[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                dic.Add(nums1[i],<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dic[nums1[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存nums2中含有nums1中的元素到结果</span></span><br><span class="line">        <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums2.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.ContainsKey(nums2[i]) &amp;&amp; dic[nums2[i]] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.Add(nums2[i]);</span><br><span class="line">                dic[nums2[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="comment">        进阶三问</span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="comment">1. 即解1，直接按照这个双指针思路查找即可。时间复杂度O(n)，空间复杂度O(1)。</span></span><br><span class="line"><span class="comment">2. 即解2，将较小的数组哈希计数，随后在另一个数组中根据哈希来寻找。时间复杂度O(max(n, m)) 空间复杂度O(min(n, m))。</span></span><br><span class="line"><span class="comment">3. 内存小，要求用原地算法。需要空间复杂度最小的解1。解1需要改造，用归并排序？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[资源]好用又好玩的体素建模软件——MagicaVoxel</title>
      <link href="2020/02/15/%E6%9D%82%E8%B0%88/%E8%B5%84%E6%BA%90-%E5%AE%89%E5%88%A9%E4%B8%80%E4%B8%AA%E4%BD%93%E7%B4%A0%E7%BB%98%E7%94%BB%E8%BD%AF%E4%BB%B6%E2%80%94%E2%80%94MagicaVoxel/"/>
      <url>2020/02/15/%E6%9D%82%E8%B0%88/%E8%B5%84%E6%BA%90-%E5%AE%89%E5%88%A9%E4%B8%80%E4%B8%AA%E4%BD%93%E7%B4%A0%E7%BB%98%E7%94%BB%E8%BD%AF%E4%BB%B6%E2%80%94%E2%80%94MagicaVoxel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MagicaVo…-啥东西"><a href="#MagicaVo…-啥东西" class="headerlink" title="MagicaVo…?啥东西?"></a>MagicaVo…?啥东西?</h1><p>MagicaVoxel是一款<strong>体素</strong>风格的，同时兼具<strong>趣味性</strong>和<strong>专业性</strong>的3D建模软件，它集3D设计、渲染、建模功能于一体，配合特定插件可以成为风格化的生产力工具！</p><blockquote><p>“体素”这个概念可以对应”像素”，当我们沉浸于8bit、16bit的2D平面像素风游戏时，诸多大神早已将目光转向了3D化的像素——“体素”。大家最熟悉的莫过于MoJang的Minecraft（虽然现在是微软的了）<img src="https://i.loli.net/2020/02/15/PTnCWGgax9h56Nq.png" alt="Minecraft"></p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E4%BD%93%E7%B4%A0/8945761?fr=aladdin#2_2">百度百科</a>：体素是体积元素（Volume Pixel）的简称……是数字数据于三维空间分割上的最小单位……概念上类似二维空间的最小单位——像素，像素用在二维计算机图像的影像数据上。有些真正的三维显示器运用体素来描述它们的分辨率，举例来说：可以显示512×512×512体素的显示器。<img src="https://i.loli.net/2020/02/15/W2JPfvDRaFQMl3X.png" alt="奇怪的知识增加了！"></p></blockquote><p>实际上这已经是一个很有年头的”老”软件了，安利此软件的文章也有很多，有兴趣可以去看看：</p><ul><li><a href="https://www.uisdc.com/3d-modeling-tool-magicavoxel">超实用！零基础也能3D建模的免费神器Magicavoxel</a></li><li><a href="https://sspai.com/post/56139">不需要专业知识和「强劲」电脑，有趣的 3D 像素画用 MagicaVoxel 轻松画</a></li><li><a href="https://www.zcool.com.cn/article/ZNjI5NjA4.html">Magicavoxel:2小时掌握的3D软件</a></li><li><a href="https://www.jianshu.com/p/0660fe4dcb1b">你知道Magicavoxel这款像素编辑器吗？</a></li><li>…</li></ul><p>可以看到在2016年）就有大神利用MagicaVoxel制作作品，而它被开发出来更早。关于这一点，可以看看作者的微博<a href="https://weibo.com/gltracy">gltracy</a>（没错，是国人），大佬似乎又要出新工具了（雕刻软件？）…可以关注支持一下。</p><h2 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h2><p>仅要3M！解压即用！更多精彩尽在<a href="http://ephtracy.github.io/">MagicaVoxel</a>！</p><h2 id="它很有趣！"><a href="#它很有趣！" class="headerlink" title="它很有趣！"></a>它很有趣！</h2><p>多种渲染模式</p><h2 id="确实称不上”专业”"><a href="#确实称不上”专业”" class="headerlink" title="确实称不上”专业”"></a>确实称不上”专业”</h2><p>你要是去跟Houdini、Maya、3DMax这种软件去比，确实不够专业，但它的优势在于可以在极短时间内创建出可用于实际生产的<strong>风格化</strong>的3D模型，在我看来这对于一般爱好者来说已经可以称得上是专业了。</p><h1 id="与Unity配合？"><a href="#与Unity配合？" class="headerlink" title="与Unity配合？"></a>与Unity配合？</h1><h2 id="如何导出？"><a href="#如何导出？" class="headerlink" title="如何导出？"></a>如何导出？</h2><h3 id="软件本体"><a href="#软件本体" class="headerlink" title="软件本体"></a>软件本体</h3><p>这个软件的工程文件后缀为.vox，具体模型格式可以到<a href="https://github.com/ephtracy/voxel-model">GitHub</a>上查看。</p><p>MagicaVoxel提供了很多导出格式，如下图所示。</p><p><img src="https://i.loli.net/2020/02/25/AQIB4bO2ns3Tji9.png" alt="导出格式很多"></p><p>一般我们常用的是.obj格式，当然使用插件也可以直接将.vox文件进行处理。</p><h3 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h3><ul><li><p>MagicaVoxel Importer</p></li><li><p>MagicaVoxel to Unity（推荐）</p></li></ul><p>MagicaVoxel to Unity插件的介绍有很多<del>作者自己写的</del>:</p><ul><li><a href="https://blog.csdn.net/u011771335/article/details/51169589">导入</a></li><li><a href="https://blog.csdn.net/u011771335/article/details/84144098">绑骨</a></li></ul><h2 id="相关作品"><a href="#相关作品" class="headerlink" title="相关作品"></a>相关作品</h2><p>可以看看<a href="https://weibo.com/p/1008080e03e4cf6bfcb1c935cccaa955cdc60c/super_index">微博超话</a>。</p><p>游戏作品似乎也不少，我极度怀疑B站的<a href="https://www.biligame.com/detail/?id=103820">一起开火车</a>是用这个软件建的模…</p><p>我所知的很多<del>胎死腹中</del>的独立游戏都是用这个软件制作的游戏素材。</p><h1 id="还有啥想写的？"><a href="#还有啥想写的？" class="headerlink" title="还有啥想写的？"></a>还有啥想写的？</h1><p>最后还是要说，软件只是工具，如何更好的利用这个工具去创造好看的、有用的内容，才是更需要去思考与投入的。</p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 建模 </tag>
            
            <tag> 体素风 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity]VRTK的基础配置、实现与UI交互</title>
      <link href="2020/02/05/Unity/Unity-VRTK%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%8EUI%E4%BA%A4%E4%BA%92/"/>
      <url>2020/02/05/Unity/Unity-VRTK%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%8EUI%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>VRTK3.3.0是开发VR程序时常用的工具，在SteamVR2.0版本Interaction System出现之前，VRTK提供了通用的VR交互模板，使得我们能够利用VRTK快速开发VR应用。</p><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>相关资源已上传百度网盘。</p><ul><li><a href="https://pan.baidu.com/s/1JZ7kAO6QI5J-XcDG4jx2kw">网盘链接</a></li><li>提取码：zvx0</li></ul><h2 id="Unity与SDK版本"><a href="#Unity与SDK版本" class="headerlink" title="Unity与SDK版本"></a>Unity与SDK版本</h2><ul><li>一般来说VRTK对Unity的版本没有太多要求，2017版本以上即可。这里使用的是Unity2018LTS版本。</li><li>VRTK版本使用3.3.0版本，这个版本的VRTK将之前小一百个示例场景整理成7个示例场景：<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/k4Z3wL9Cda8FO2K.png"></li><li>要兼容VRTK，SteamVR需要老版本1.2.3，这是因为SteamVR2.0重新设计了交互流程，将SteamVR也转换成支持多硬件的插件平台了，VRTK用到的一些API有了修改。</li></ul><h2 id="SDKManager和SDKSetups"><a href="#SDKManager和SDKSetups" class="headerlink" title="SDKManager和SDKSetups"></a>SDKManager和SDKSetups</h2><p>场景中创建空物体，命名为“SDKManager”，位置旋转置零，并添加“VRTK_SDKManager”组件。</p><p>在SDKManager游戏物体下新建空物体“SDKSetups”，这个空物体下放置各硬件的SDK配置（例如SteamVR的CameraRig）。</p><p>使用SteamVR的功能，在SDKSetups下新建空物体“SteamVR”，添加“VRTK_SDKSetup”。将SteamVR的CameraRig拖入到此物体下。组件中“SDK Selection”选择“SteamVR(Standalone:OpenVR)”，点击“Populate Now”按钮即可。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/lZr4A2JEWCuhpQk.png"></p><p>同时，在SDKManager中的“Setups”项中点击“Auto Populate”按钮，进行自动配置存在的Setup。<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/Wk4NdGRSZAasgBQ.png"></p><h2 id="VR模拟器"><a href="#VR模拟器" class="headerlink" title="VR模拟器"></a>VR模拟器</h2><p>VRTK自带VR模拟器的Setup，可以在Project面板中搜索“VRSimulator_CameraRig”，找到预制体，创建对应的Setup添加到SDKManager中即可。</p><h1 id="交互基础"><a href="#交互基础" class="headerlink" title="交互基础"></a>交互基础</h1><p>配置好SDKManager和SDKSetups后，运行程序还是会报错，这是因为没有在SDKManager中配置左右手柄的引用（Script Aliases）。</p><h2 id="配置左右手柄"><a href="#配置左右手柄" class="headerlink" title="配置左右手柄"></a>配置左右手柄</h2><ul><li>这个左右手柄的引用主要用作挂载交互组件以及自定义的和左右手相关的组件。当我们选择不同的SDKSetup运行程序时，这个引用物体会自动成为相应CameraRig的左右手的子物体。</li><li>在场景中新建空物体“VRTK_Scripts”，并创建“LeftController”和“RightController”子物体，挂载“VRTK_ControllerEvents”。<img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/yxEnvet78G5lMOY.png"></li><li>将这俩空物体分别给SDKManager中“Script Aliases”项赋值即可。</li></ul><h2 id="配置VRTK中的UI交互"><a href="#配置VRTK中的UI交互" class="headerlink" title="配置VRTK中的UI交互"></a>配置VRTK中的UI交互</h2><p>VR环境中，常用的UI交互手段为：</p><ul><li>注视交互</li><li>射线交互</li><li>触碰交互</li><li>自然交互</li></ul><p>先以射线功能为基础，完成VRTK环境下用户与UI交互的需求。</p><h3 id="添加射线功能"><a href="#添加射线功能" class="headerlink" title="添加射线功能"></a>添加射线功能</h3><p>Controller上添加“VRTK_Pointer”组件，用以从手柄发出射线。</p><p>其中，“Pointer Activation Settings”项中“Activation Button”项为射线打开的开关按键，默认是触控板按下。</p><p>具体按键含义可以对照VRTK的文档以及对应SDK的文档，下图是HTC Vive对应的按键。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/8DrgvZdKFGyJXia.png"></p><blockquote><p>注意：这里的VRTK_Pointer组件只是“发出射线并交互”功能的组件，没有“渲染射线”的功能。如果你没有添加“Pointer Renderer”组件的话，一般默认是不渲染出来射线的。</p><p>在3.3.0版本的VRTK中，你没添加“Pointer Renderer”组件的话，会在运行时自动送你一个“VRTK_Straigh Pinter Renderer”组件，用来以直线渲染射线。</p><p>还有一种射线的渲染方式是曲线渲染，用在传送上面比较多。可以在“[004 - Locomotion] Teleporting”示例场景查看。</p></blockquote><h3 id="与UGUI的交互"><a href="#与UGUI的交互" class="headerlink" title="与UGUI的交互"></a>与UGUI的交互</h3><p>Controller上添加“VRTK_UIPointer”组件，使得从手柄发出的射线可以和UGUI进行交互。</p><p>场景中新建Canvas，设置模式World Space，缩放更改为0.003，分辨率为3。</p><p>添加组件“VRTK_UICanvas”，之后在这个新建的Canvas下创建UGUI即可。</p><blockquote><p>记住UIPointer和UICanvas是一对就行。</p></blockquote><blockquote><p>这里有一个坑：如果在添加Canvas之前，添加过VRTK的SDKSwitcher，就会出现无法与UI进行交互的问题。这是因为SDKSwitcher中有一个“Event System”组件，并且是隐藏的。我们应该保证场景中有一个显示的“Event System”组件，这样UGUI才能接收到交互事件。</p></blockquote><blockquote><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/urWq48EdYO3cLbj.png"></p></blockquote><h3 id="触碰交互"><a href="#触碰交互" class="headerlink" title="触碰交互"></a>触碰交互</h3><p>Controller上添加“VRTK_InteractTouch”，用以开启触碰功能。</p><p>Canvas上的“VRTK_UICanvas”组件将“AutoActivateWithinDistance”设置为0.2，这意味着当手柄与UI按钮的距离小于0.2，会自动触发按钮事件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，基于VRTK的环境配置和简单UI交互就配置好了，下一篇写一下常用的VRTK组件。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> VR </tag>
            
            <tag> VRTK </tag>
            
            <tag> SteamVR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转载]Unity光照模式的总结</title>
      <link href="2020/01/19/Unity/%E8%BD%AC%E8%BD%BD-Unity%E5%85%89%E7%85%A7%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>2020/01/19/Unity/%E8%BD%AC%E8%BD%BD-Unity%E5%85%89%E7%85%A7%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本篇文章转载自<a href="https://zhuanlan.zhihu.com/p/102410358">知乎-MusouCrow’BLOG-Unity光照模式的总结</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近日在琢磨Demo应该选择怎样的光照模式，遂做了个试验：对比在同一场合下，各种模式的情况。故以此文记录之（版本为2019.2、平台为Standalone、渲染管线为Builtin）。</p><h1 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h1><p>环境光(Ambient)严格来说并不是一种光照，它只是单纯的为所有显示元素上色罢了。可以理解为2D游戏便是有个(255, 255, 255)环境光。可于(Window → Rendering → Lighting Settings)下的Environment Lighting进行设置。</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/v2-129d1fa63e98971d0a65aabc6657b472_hd.jpg" alt="环境光"></p><p>环境光是无论如何都需要的，一般用于决定画面的底色。下图便是用了白色的效果：</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/v2-ec2ba57002343e76338cd668845aadc7_hd.jpg" alt="白色的环境光"></p><p>看到上图便能理解我说的「环境光严格来说并不是一种光照」，毕竟连影子都没有，整个画面显得很单薄。但事实上在早期、以及现在一些不依赖光影的游戏是有这种做法的。它们一般会采用类似2D游戏的做法，在素材层面解决各种显示效果问题。对于不依赖光影、强调美术的绝对控制的游戏，使用纯环境光是个方案。</p><p>　　顺带一提，在Environment Lighting设置下的Gradient与Skybox模式有着不一样的效果，属于更高级的环境光实现。</p><h1 id="实时光"><a href="#实时光" class="headerlink" title="实时光"></a>实时光</h1><p>　实时光(Realtime)顾名思义，就是每时每刻都在进行的光照。在Light组件的Mode属性设置为Realtime即是。实时光的优缺点很明显，如下：</p><p>优点</p><ul><li>游戏时可随时改变光照的状态，即刻产生反应</li><li>随取随用，无需烘焙</li><li>光照效果最好</li></ul><p>缺点</p><ul><li>在正向渲染(Forward Rendering)下，画面同时出现多个光照时，开销较大</li><li>为了节能，某些设备、设置下，光照的数量有限</li></ul><p>实时光一般就是开箱即用到的光照，效果如下：</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/v2-0c28c7abe4b4d0dfb45979b29443a4fa_hd.jpg"></p><p>可以看得出，各项消耗指标都比纯环境光要高，而该场景只有三项光照（平行光1个、聚光灯2个）。故一般游戏都不会如此奢侈，会采用各种手段来达到相同的效果。</p><p>　　而以上却还不是效果的极致，还差个全局光照(Global Illumination)呢。刚才所见的光照只是「直接的光照」罢了，它只会考虑到照到了谁便处理谁，没有从全局的角度去考虑。在开启全局光照后，除了直接光照之外，还会产生物件之间相互反射的间接光照。效果如下：</p><p><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/v2-7d97a673af4351ffa501b37cb7148f26_hd.jpg"></p><p>从画面效果来看变得更为深邃了，墙壁与地板都有了反射后的光渍，而各项指标实际上与局部并无不同（疑似）。使用它的前提是要在上文的Lighting Settings下开启Realtime Global Illumination，并且为静态物件做好Static标记。具体实现细节请自行查阅官方文档，在此不表。</p><p>　　当然，这并不代表全局光照优于局部光照，就比如有些游戏的画面风格并不喜欢那些全局光照带来的光渍。还是要看想要怎样的美术效果。</p><h1 id="烘焙光"><a href="#烘焙光" class="headerlink" title="烘焙光"></a>烘焙光</h1><p>烘焙光(Baked)可谓实时光的反面：根据光照信息预先渲染成贴图，最后盖到场景上。这个「根据光照信息预先渲染成贴图」的过程，是为烘焙。而烘焙的类型、算法、设置有着多样化的选择，直接影响烘焙的时长、效果、贴图大小与数量。也因烘焙的特性，只适用于静态物件（标记为Static的对象）。优缺点如下：</p><p>优点</p><ul><li>部分渲染元素（取决于烘焙类型）没有实时运行的开销</li><li>属于全局光照，拥有间接光</li></ul><p>缺点</p><ul><li>光照属性不能运行时修改</li><li>动态物件不受影响</li><li>烘焙耗时</li></ul><p>烘焙类型主要分三种，效果如下：</p><ul><li><p>Subtractive: 全烘焙<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/v2-be2760564cb5b2f44d9e01fb8d4e7564_hd.jpg"></p></li><li><p>Shadowmask: 烘焙阴影与间接光<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/v2-7649567c407cfaa5d3b8fa917a374b32_hd.jpg"></p></li><li><p>Backed Indirect: 只烘焙间接光<br><img src="https://daachun.coding.net/p/blogimg/d/blogimg/git/raw/master/v2-2dc290b8a1738638e1a0538b2fdf23ed_hd.jpg"></p></li></ul><p>可以看到效果是一个比一个好，但性能却是一个比一个耗。并且可以看出，由于烘焙设置的问题，效果是不如实时光的。而通过设置达到最优的话，烘焙时长则又是个问题了，鱼和熊掌不可兼得啊（砸钱便能我全都要）。</p><p>　　对于Subtractive，只需把Light组件的Mode属性设置为<strong>Baked</strong>即可。对于其余两种，实际上是一种实时光+烘焙光的混合方案，则需设置为<strong>Mixed</strong>。由于动态对象不受烘焙光影响的特性，Subtractive下的胶囊仔直接跟纯环境光时一个样了。解决方案有很多种，如采用Mixed方案（静态物件烘焙光、动态物件实时光）、<a href="https://docs.unity3d.com/Manual/LightProbes.html">Light Probes</a>等。</p><p>　　顺带一提，关于Shadowmask，在阴影设置中可调为<strong>Distance Shadowmask</strong>。如此将取决于阴影距离的设置，在阴影距离内的阴影，将采用实时阴影，距离之外的则是烘焙阴影。也算是一种提升品质的方式吧。</p><p>　　烘焙光在业界的应用相当广泛，其中Subtractive式烘焙在早期游戏与现代手游可谓家常便饭，妥善使用Light Probes也能达到不俗的效果。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上只是本人粗略的实验与记录，实际上光照的内容浩如烟海，远非本篇所能涵盖。在光照方面本人也只能算是初学者，有所不对还请海涵，并欢迎指教。</p><hr><blockquote><p>简单在这里做个转载，对于光照系统的总结可以查看<a href="https://docs.unity3d.com/Manual/LightingOverview.html">Unity官方文档的光照部分</a>。</p><p>Unity官方也有相关文章与演讲，有空搬过来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 转载 </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏设计与设计模式</title>
      <link href="2018/11/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2018/11/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为什么要学习设计模式？与游戏开发有何关联？</p><!---more---><h1 id="为什么要学习设计模式？"><a href="#为什么要学习设计模式？" class="headerlink" title="为什么要学习设计模式？"></a>为什么要学习设计模式？</h1><p>针对程序设计的新手，学习设计模式是快速入门面向对象程序设计的方法。设计模式范例能够使我们了解特定需求下，使用哪种方法来解决问题相对稳定和高效。</p><p>设计模式实际就是学习面向对象程序设计的最佳模板，同时也是学习先人智慧与积累的一种方法。设计模式的方法已经被验证过，解决问题时不用重新思考新的解决方案<del>合理偷懒</del>。</p><h1 id="游戏中有必要使用设计模式吗？"><a href="#游戏中有必要使用设计模式吗？" class="headerlink" title="游戏中有必要使用设计模式吗？"></a>游戏中有必要使用设计模式吗？</h1><p>很有必要，游戏程序设计开发实际上是一个系统工程，也属于软件工程的一个例子，学习设计模式能够加速开发，实现需求，并使游戏在快速更新的过程中保持稳定。</p><p>我们从以下几个方面来讨论：</p><h2 id="市场的多样性"><a href="#市场的多样性" class="headerlink" title="市场的多样性"></a>市场的多样性</h2><p>目前的游戏市场内，有很多个游戏种类，那么为了快速开发产品，游戏团队应该设计出一套属于自己的“游戏开发框架”。此框架除了涉及程序设计方面，美术、策划的工作流也应整合在其中。“设计模式”能够提供框架开发的参考模板。</p><h2 id="需求的快速变化"><a href="#需求的快速变化" class="headerlink" title="需求的快速变化"></a>需求的快速变化</h2><p><del>策划我杀了你🐎</del></p><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>游戏平台（游戏引擎）有很多，但游戏的核心是游戏玩法。设计程序时应将游戏玩法独立出来，不依赖任何游戏平台。这种独立的设计有利于多平台快速移植，将“游戏核心内容”和“应用平台”进行合理分割。在这之中，设计模式提供了明确的设计指南。</p><h2 id="与多类技术结合"><a href="#与多类技术结合" class="headerlink" title="与多类技术结合"></a>与多类技术结合</h2><p><del>你做游戏不赚钱吗</del></p><p>浅显来讲，游戏作为系统工程，是多种学科、多种技术集合的结果，那么针对多种技术，如何整合、串联和结合就是一个很大的问题。设计模式给出一定的建议，引导将各项技术之间进行接口的分割，并进行串联组合。</p><p>结论就是赶紧学。</p><h1 id="设计模式的应用"><a href="#设计模式的应用" class="headerlink" title="设计模式的应用"></a>设计模式的应用</h1><p>GoF的23种设计模式可以分为3大类：</p><ul><li>生成模式（Creational）：产生对象的过程及方式</li><li>结构模式（Structural）：类或对象之间组合的方式</li><li>行为模式（Behavioral）：类或对象之间互动或责任分配的方式</li></ul><h2 id="过度设计"><a href="#过度设计" class="headerlink" title="过度设计"></a>过度设计</h2><p>无限制地使用设计模式来进行软件设计，就会产生“过度设计（Over-Engineering）”的问题，设计师将原本不需要的设计需求加入到实现中，但可能这些设计永远都不会用到。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式起源与常见设计原则</title>
      <link href="2018/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>2018/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式学习<del>与复读</del>，开坑开坑。</p><!---more---><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>设计模式系列笔记基于蔡升达的《设计模式与游戏完美开发》一书，主要内容是书本部分知识的记录<del>复读</del>，以及个人的一些理解。</p><p>《设计模式与游戏完美开发》以一款游戏《P级阵地》的设计作为范例，通过游戏内各种需求作为引导进行设计模式的讲解。</p><p>我个人认为这种一个项目贯穿始终的书十分值得一看，再经过群内大佬的推荐，终于下定决心仔细研读，希望能够学习到各种设计模式的特点和在Unity项目中的应用。</p><h1 id="设计模式起源与常见设计原则"><a href="#设计模式起源与常见设计原则" class="headerlink" title="设计模式起源与常见设计原则"></a>设计模式起源与常见设计原则</h1><h2 id="GoF"><a href="#GoF" class="headerlink" title="GoF"></a>GoF</h2><p>1994年出版的《设计模式》一书的作者一共有4位，这4位作者被人称为“4人组”，即GoF（Gang of Four）。</p><p>《设计模式（Design Patterns）》翻开了面向对象程序设计的新篇章。</p><blockquote><p>“每一种模式都在说明一个一再出现的问题，并描述解决方案的核心，让你能够据以变化，产生出各种格式，来解决上万个类似的问题”。</p></blockquote><h2 id="“模式”的概念"><a href="#“模式”的概念" class="headerlink" title="“模式”的概念"></a>“模式”的概念</h2><p>引入“模式”的概念，让软件设计能以经验积累的方式，将一些经常用来解决特定情况的“类设计”“对象组装”加以整理并定义成为一种“设计模式”。</p><p><del>说白了就是能偷懒</del></p><h1 id="软件的设计模式"><a href="#软件的设计模式" class="headerlink" title="软件的设计模式"></a>软件的设计模式</h1><p>每一种设计模式满足以下几项要求：</p><ul><li>满足<a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">面向对象设计的原则</a></li><li>解决一再出现的问题（总结）</li><li>解决问题的方案和问题核心的关键点（击中痛点）</li><li>可以重复使用的解决方案（可复用）</li></ul><p>个人理解：设计模式是解决常见的、有共性的问题的“攻略”，根据这份“攻略”可以快速实现需求，并有一定的可靠性。</p><h1 id="面向对象设计中常见的设计原则"><a href="#面向对象设计中常见的设计原则" class="headerlink" title="面向对象设计中常见的设计原则"></a>面向对象设计中常见的设计原则</h1><p><em>《Agile Software Development:Principles,Patterns,and Practices》</em> 中对常见的设计原则做了清晰说明，一共5个：</p><h2 id="单一职责原则（SRP-Single-Responsibility-Principle）"><a href="#单一职责原则（SRP-Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（SRP: Single Responsibility Principle）"></a>单一职责原则（SRP: Single Responsibility Principle）</h2><blockquote><p>“一个类只负责一件事”</p></blockquote><p>系统中功能的切分和归属是很令人困扰的，项目开发中经常会不断地向同一个类上添加功能，最后导致这个类十分庞大、接口过于复杂：类难以维护，不容易了解类的功能。整个项目会过度依赖于这个类。</p><p>实现“单一职责原则”，要不断地进行“<strong>类重构</strong>”，将类中与实现相关功能的部分抽取出来，另外封装成新的类，再利用组合的方式将新增的类加入到原类中，慢慢地就能实现此原则。</p><h2 id="开——闭（OCP-Open——Closed-Principle）"><a href="#开——闭（OCP-Open——Closed-Principle）" class="headerlink" title="开——闭（OCP: Open——Closed Principle）"></a>开——闭（OCP: Open——Closed Principle）</h2><blockquote><p>“对扩展开放、对修改关闭”</p></blockquote><p>对于已经测试完成或已经上线运行的功能，应<strong>关闭对修改的需求</strong>，也就是不能再修改这个类的任何接口或实现内容。</p><p>但在需要增加需求时，不能置之不理，所以应该“对功能的增加保持开放”。这需要抽象化各个功能的“操作方法”，设计为<strong>接口</strong>，将“功能的实现”移到子类中。这之后添加功能，就是“增加子类”。</p><p><del>大概就是写个框架？</del></p><h2 id="里氏替换原则（LSP-Liskov-Substitution-Principle）"><a href="#里氏替换原则（LSP-Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（LSP: Liskov Substitution Principle）"></a>里氏替换原则（LSP: Liskov Substitution Principle）</h2><blockquote><p>“子类必须能够替换父类”</p></blockquote><p>通过继承，功能使用父类，不必在意是怎样的子类，只知道是继承了父类的子类即可。必须不能使用强制类型转换：“不能将对象强制转型为子类”。</p><h2 id="依赖倒置原则（DIP-Dependence-Inversion-Priciple）"><a href="#依赖倒置原则（DIP-Dependence-Inversion-Priciple）" class="headerlink" title="依赖倒置原则（DIP: Dependence Inversion Priciple）"></a>依赖倒置原则（DIP: Dependence Inversion Priciple）</h2><blockquote><ul><li>“高层模块不应该依赖于底层模块，两者都应该依赖于抽象概念”</li><li>“抽象接口不应该依赖于实现，而实现应该依赖于接口”</li></ul></blockquote><p>对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>解决：上层调用下层，使得上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而大大提高了开发的成本。应由“高层模块定义接口”，到“底层模块遵循这个接口实现”。</p><h2 id="接口隔离原则（ISP-Interface-Segregation-Principle）"><a href="#接口隔离原则（ISP-Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（ISP: Interface Segregation Principle）"></a>接口隔离原则（ISP: Interface Segregation Principle）</h2><blockquote><p>“客户端不应该被迫使用它们用不到的接口方法”</p></blockquote><p>当项目中出现了一个负责主要功能的类，而且这个类还必须负责跟其他子系统进行沟通时，针对每一个子系统的需求，主要类就必须增加对应的方式。这意味着增加了主类的接口复杂度。</p><p>应通过“功能的切分”和“接口的简化”来减少这类问题的发生，或者直接重新按照设计模式来规划类。</p><h2 id="What’s-More…"><a href="#What’s-More…" class="headerlink" title="What’s More…"></a>What’s More…</h2><p>除上述5种常用原则之外，还有一些常用原则。</p><p><strong>最小知识原则（LKP: Lest Knowledge Principle）</strong></p><p>设计一个类的时候，越少使用到其他类提供的功能越好。也就是降低了耦合度，同时增加了重用性。</p><p><strong>少用继承多用组合原则</strong></p><p>对用类的组合，少用继承。</p><p>“时钟”类和“闹钟”类，在设计时当然可以使得“闹钟”继承“时钟”，但在系统中，可能只需要闹钟的功能，对当前时间并没有大的需求，这就可能导致“时钟”的功能影响到系统的使用。</p><p>解决这方面的问题，就是在“闹钟”类中声明一个“时钟”类的类成员，将继承改为类的组合，这样除了实现基本功能之外，还加强了语义，并易于维护。</p><p><strong>与设计模式之间的关系</strong></p><p>“设计模式”是在符合“面向对象设计原则”的前提下，解决软件设计问题的实践成果。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-8</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-8/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>添加状态系统。</p><!---more---><h2 id="回合制对战"><a href="#回合制对战" class="headerlink" title="回合制对战"></a>回合制对战</h2><h3 id="状态系统"><a href="#状态系统" class="headerlink" title="状态系统"></a>状态系统</h3><p>在前几节中，我们定义了三种Skill类型。直接治疗类型和直接伤害类型的技能我们都进行了完整的实现，但没有对持续类型的技能进行实现。我们明确了持续类技能相当于给角色添加一个标记，标记的生命周期用状态系统来控制，标记实现具体的功能。</p><pre><code>enum StateType&#123;    DamageOverTime,    HealOverTime,&#125;class State&#123;    public StateType type;    public int time;    public int data;    public State(StateType type, int time, int data)    &#123;        this.type = type;        this.time = time;        this.data = data;    &#125;&#125;</code></pre><p>注意：状态类不能有权限给别人改写数据。若状态主动更改角色数据，那么就跟角色自身更改自身数据产生了耦合，不利于后期的设计。我们可以设计为角色单向依赖状态来更改自身数据。</p><p>我们改写Role，为其增加一个存放State的List，并添加AddState()方法。扩展BeHit()方法：</p><pre><code>case SkillType.AddState:    AddState(skill.state);    break;public virtual bool AddState(State state)&#123;    states.Add(state.Copy());    return true;&#125;public virtual bool StateEffect()&#123;    foreach (var state in states)    &#123;        if(state.time &lt;= 0)        &#123;            continue;        &#125;        if(state.type == StateType.DamageOverTime)        &#123;            Console.WriteLine(&quot;DOT生效&quot;);            CostHp(state.data);        &#125;        else if(state.type == StateType.HealOverTime)        &#123;            Console.WriteLine(&quot;HOT生效&quot;);            HealHp(state.data);        &#125;        state.time--;    &#125;    // Todo: 遍历删除已经失效的状态。从列表删除元素时，注意从后往前删    return true;&#125;</code></pre><p>这里有一个细节，观察AddState()方法，你会发现这里是使用state.Add(state.Copy())，这里的Copy()方法实际上是为传入的State创建了一个新的复制。这么做的原因是之前这些参数传入的都是引用，那么会导致StateEffect()方法直接修改传入的那个实例，这可能会导致一些问题。那么我们新申请内存空间，基于原来那个实例的模板（持续时间和值）新建一个实例以供修改即可。</p><p>要注意后期的垃圾处理。</p><p>在RoleAct()方法中添加判定时机：</p><pre><code>self.StateEffect();</code></pre><p>之后在Main中为角色添加新技能吧：</p><pre><code>// 添加dot技能State state = new State(StateType.DamageOverTime, 3, 5);player.skills.Add(Skill.CreateAddStateSkill(SkillTarget.Enemy, state));</code></pre><p>至此状态添加功能基本实现。</p><h3 id="状态消除与回合显示优化"><a href="#状态消除与回合显示优化" class="headerlink" title="状态消除与回合显示优化"></a>状态消除与回合显示优化</h3><p>上一节我们还没有实现遍历删除失效状态的方法，并且返回值也并没有相关的内容，这一节我们完善这一步骤。</p><p>首先要注意要删除List中某个或几个元素，直接Remove()传入一个参数相同的实例是没有用的。如果这里我们用foreach的话是实现不了这个功能的。</p><p>那么怎样才能遍历List之后删除某个特定条件的元素呢？</p><blockquote><p><a href="https://www.cnblogs.com/hedianzhan/p/9130296.html">C#遍历List并删除某个或者几个元素的方法</a></p></blockquote><blockquote><p>用for正序遍历删除,只删除了一个姓名为Tang的学生。为什么会出现这种情况呢？<br>这是因为当i=1时，满足条件执行删除操作，会移除第一个Tang，接着第二个Tang会前移到第一个Tang的位置，即游标1对应的是第二个Tang。<br>接着遍历i=2，也就跳过第二个Tang。</p></blockquote><p>得到答案：用for循环倒序遍历删除，即判断每一个state实例的持续时间，若time&lt;=0就删除掉，不进入结算。更改StateEffect()：</p><pre><code>for (int i = states.Count -1 ; i &gt;= 0; i--)&#123;    if (states[i].time &lt;= 0)    &#123;        Console.WriteLine(&quot;&#123;0&#125;身上的&#123;1&#125;状态失效&quot;, name, states[i].type);        states.Remove(states[i]);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-7</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-7/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>战斗功能抽象化。</p><!---more---><h2 id="回合制对战"><a href="#回合制对战" class="headerlink" title="回合制对战"></a>回合制对战</h2><h3 id="优化技能目标功能"><a href="#优化技能目标功能" class="headerlink" title="优化技能目标功能"></a>优化技能目标功能</h3><p>在之前一节中，我们实现的技能目标功能是将伤害技能和治疗技能的目标写死了，但实际上，治疗技能不光能够为自身回复，还能为友军、敌方回复。就此功能，我们对Skill类进行扩展，添加一个SkillTarget的枚举类型属性来记录技能的目标。</p><p>换言之，在全局的GetSkillTarget()方法中我们可以直接判断技能目标类型来确定返回值，而不是只依据技能类型：</p><pre><code>static Role GetSkillTarget(Skill skill, Role self, Role enemy)&#123;    if (skill.target == SkillTarget.Enemy)    &#123;        return enemy;       &#125;else if(skill.target == SkillTarget.Self)    &#123;        return self;    &#125;    return null;&#125;</code></pre><p>有得必有失，在Skill的Create方法中，必须提供SkillTarget作为参数传入。</p><h3 id="战斗功能抽象化"><a href="#战斗功能抽象化" class="headerlink" title="战斗功能抽象化"></a>战斗功能抽象化</h3><p>一直到现在，我们的战斗过程还是用简单的while循环驱动，并由玩家和怪物的血量来控制。</p><p>我们可以发现，回合制游戏战斗过程具有对称性：我动一下，敌方动一下。那么根据这一特性，将战斗过程抽象化实现。同时可以优化战斗过程的显示方法。</p><p>定义全局方法RoleAct()，它描述每回合特定Role的行动。</p><pre><code>static bool RoleAct(Role self,Role other)&#123;    Console.WriteLine(&quot;---------------&quot;);    if (self == player)        &#123;        Console.ForegroundColor = ConsoleColor.Green;    &#125;    else    &#123;        Console.ForegroundColor = ConsoleColor.Gray;    &#125;    Console.WriteLine(&quot;&#123;0&#125;的回合&quot;, self.name);    Skill skill = self.SelectSkill();    Role target = GetSkillTarget(skill, self, other);    target.BeHit(skill);    if (target == self)    &#123;        Console.WriteLine(&quot;&#123;0&#125;的生命:&#123;1&#125;&quot;,self.name , self.hp);    &#125;    else     &#123;        Console.WriteLine(&quot;&#123;0&#125;被攻击，生命:&#123;1&#125;&quot;, other.name,other.hp);    &#125;    if (other.hp &lt;= 0 || self.hp &lt;= 0)        &#123;        return false;    &#125;    return true;&#125;</code></pre><p>这样就可以在循环中使用：</p><pre><code>RoleAct(player, monster);RoleAct(monster, player);</code></pre><p>这种抽象化的过程肯定不是最优解，但作为学习素材足够了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-6</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-6/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>优化技能系统，添加技能类型。</p><!---more---><h2 id="回合制对战"><a href="#回合制对战" class="headerlink" title="回合制对战"></a>回合制对战</h2><h3 id="特殊技能的实现"><a href="#特殊技能的实现" class="headerlink" title="特殊技能的实现"></a>特殊技能的实现</h3><p>实现玩家半血后进入愤怒状态，攻击力变为3倍的功能。</p><p>将BeHit方法抽象，在Player和Monster类中重写BeHit方法，以玩家为例：</p><pre><code>public override void BeHit(int cost_hp)&#123;    base.BeHit(cost_hp);    // 判断“狂暴”    if (hp * 1.0f / maxHp &lt; 0.5f)    &#123;        Console.WriteLine(&quot;愤怒！攻击力大大增加！&quot;);        foreach (var skill in skills)        &#123;            skill.SetDamageMutiply(3);        &#125;    &#125;&#125;</code></pre><p>注意：int类型的hp除以同为int类型的maxHP得到只能是int，在这里也就是非0即1，要转化成float类型。</p><h3 id="优化技能系统"><a href="#优化技能系统" class="headerlink" title="优化技能系统"></a>优化技能系统</h3><p>先搞清楚回合制游戏中的常见技能种类</p><ol><li>直接伤害类   - 直接</li><li>直接治疗类   - 直接</li><li>持续伤害类   - 持续</li><li>持续治疗类   - 持续</li><li>定身、沉默、眩晕等debuff     - 持续</li><li>无敌、增加攻击、防御等buff   - 持续</li></ol><p>归纳：持续类技能使用<strong>状态</strong>来实现。那么如果一个技能给角色附加了一个状态，这之后状态的效果、持续时间、消失与这个技能没有关系，和状态系统有关。我们用状态系统来控制这些状态。</p><p>例如上一节中“愤怒”的实现可以归为buff的状态。</p><blockquote><p>好的框架设计，最重要的是对逻辑的理解。</p></blockquote><p>基于以上理解，将技能系统进行细化，增加“技能目标”的定义。</p><p>将Skill分为3种类型：</p><ol><li>直接伤害类</li><li>治疗类</li><li>添加状态</li></ol><pre><code>enum SkillType&#123;    Damage = 1,     // 直接伤害    Heal,           // 治疗    AddState        // 添加状态&#125;</code></pre><p>完善技能类的内容，添加static工具类用于创建技能，删除原来的构造函数：</p><pre><code>public static Skill CreateDamageSkill(int damage)&#123;    Skill s = new Skill();    s.skillType = SkillType.Damage;    s.damage = damage;    return s;&#125;public static Skill CreateHealSkill(int heal)&#123;    Skill s = new Skill();    s.skillType = SkillType.Heal;    s.heal = heal;    return s;&#125;</code></pre><p>同时更改相关的技能创建语句。将Role类内的BeHit方法进行优化：</p><pre><code>public virtual void BeHit(Skill skill)&#123;    switch (skill.type)    &#123;        case SkillType.Damage:            hp -= skill.damage;            if (hp &lt; 0) hp = 0;            break;        case SkillType.Heal:            hp += skill.heal;            if (hp &gt; maxHp) hp = maxHp;            break;    &#125;&#125;</code></pre><p>并增加一个获取目标Role的static方法：</p><pre><code>static Role GetSkillTarget(Skill skill, Role self, Role enemy)&#123;    if (skill.type == SkillType.Damage)    &#123;        return enemy;       &#125;else if(skill.type == SkillType.Heal)    &#123;        return self;    &#125;    return null;&#125;</code></pre><p>完善相关语句，完成技能选择、治疗技能、伤害技能的实现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-5</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-5/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>让我们在回合制对战中加入技能系统。</p><!---more---><h2 id="回合制对战"><a href="#回合制对战" class="headerlink" title="回合制对战"></a>回合制对战</h2><h3 id="加入技能系统"><a href="#加入技能系统" class="headerlink" title="加入技能系统"></a>加入技能系统</h3><p>加入技能系统之前需要考虑清楚对应数据结构。一个角色可能有多个技能，所以使用List来存储技能<strong>Skill</strong>类。</p><pre><code>class Skill&#123;    int skillType = 1;    // 属性    public int damage &#123; get; private set; &#125;    public Skill(int skillType,int damage)    &#123;        this.skillType = skillType;        this.damage = damage;    &#125;    public int GetDamage()    &#123;        return damage;    &#125;&#125;</code></pre><p>那么先设定一个角色可以随机选择技能释放，在角色中添加随机种子并应用到获取随机技能。</p><pre><code>public List&lt;Skill&gt; skills = new List&lt;Skill&gt;();Random random = new Random();public Skill RandomSkill()&#123;    return skills[random.Next(0, skills.Count)];&#125;</code></pre><p>那么即可将普通攻击归为一个技能，并入技能类中。将角色的attack字段和相关参数删除。同时，更改主循环内容。</p><pre><code>monster.BeHit(player.RandomSkill().damage);Console.ForegroundColor = ConsoleColor.DarkGreen;Console.WriteLine(&quot;【怪物】被攻击，目前生命：&#123;0&#125;&quot;,  monster.hp);if (monster.hp &lt;= 0) break;</code></pre><h3 id="玩家选择技能"><a href="#玩家选择技能" class="headerlink" title="玩家选择技能"></a>玩家选择技能</h3><p>设计**ChooseSkill()**方法来实现玩家选择技能。其中，玩家操作用Console.ReadLine()，通过判断success条件来判断返回的Skill对象。</p><pre><code>public Skill ChooseSkill()&#123;    bool success = false;    int n = -1;    while (!success)    &#123;        Console.WriteLine(&quot;请选择技能 &#123;0&#125;~&#123;1&#125;&quot;, 1,skills.Count);        string input = Console.ReadLine();        success = int.TryParse(input, out n);        if (n &lt;= 0 || n &gt; skills.Count)        &#123;            success = false;        &#125;    &#125;    return skills[n - 1];&#125;</code></pre><p>改写主循环</p><pre><code>var skill = player.ChooseSkill();monster.BeHit(skill.damage);</code></pre><h3 id="利用继承实现框架设计"><a href="#利用继承实现框架设计" class="headerlink" title="利用继承实现框架设计"></a>利用继承实现框架设计</h3><p>在这个例子中，怪物和玩家本质上是一致的Role对象，那么为了在主循环内统一使用格式，需要我们设计类之间的继承关系。</p><p>设定Player类和Monster类，继承Role类。注意：Player类和Monster类的构造函数同样要和Role类相同。</p><pre><code>class Player : Role&#123;    public Player(int _hp) : base(_hp) &#123; &#125;&#125;class Monster : Role&#123;    public Monster(int _hp) : base(_hp) &#123; &#125;&#125;</code></pre><p>Role类为基类，那么在基类中定义一个virtual方法</p><pre><code>public virtual Skill SelectSkill()&#123;    return null;&#125;</code></pre><p>在Player类和Monster类中override实现即可。例如，对于Monster类：</p><pre><code>class Monster : Role&#123;    public Monster(int _hp) : base(_hp) &#123; &#125;    public override Skill SelectSkill()    &#123;        return skills[random.Next(0, skills.Count)];    &#125;&#125;</code></pre><blockquote><p>CSDN：<a href="https://blog.csdn.net/inter_peng/article/details/53940179">函数重载（overload）和函数重写（override）的基本规则</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-4</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-4/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编写一个控制台回合制游戏。练习面向对象的程序设计思维。</p><!---more---><h2 id="回合制对战"><a href="#回合制对战" class="headerlink" title="回合制对战"></a>回合制对战</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这个主题主要练习面向对象的程序设计思维。</p><p>从设计的角度来说，本对象应该仅管理本对象相关的信息。例如写一个玩家类，应设计为“被攻击”的方法而不是“攻击他人”的方法。</p><p>回合制对战基本设计思路：</p><ol><li>实现回合制对战基本框架</li><li>加入技能系统，考虑清楚数据结构</li><li>技能的配套方法，比如一开始添加技能</li><li>玩家可以选择技能，怪物随机释放</li><li>利用继承实现框架设计</li><li>初级的特殊技能实现（愤怒状态的实现）</li><li>状态系统实现特殊技能</li></ol><p>这里有个思路上的tip：实现功能要从最基本的地方开始设计，而不是一下子把所有的东西都想好。从最基本的地方来设计是有利于轻松实现的，而一下子想太复杂就会让人千头万绪，不知所措。</p><p>同理，等一步一步逻辑搭建起来后，再回头去将需要保护的变量private起来。</p><blockquote><p>敏捷开发:当策划给出策划案，先不管那么多复杂的东西，快速建立一个原型，让成员先看一下实现效果。基于这个实现效果再去决定下一步是重做还是继续完善。使用快速迭代、循序渐进的方法进行软件开发，将一个大项目分为多个独立运行的小项目，并分别完成。具体内容以后再做详细分析。</p></blockquote><blockquote><p>百度百科：<a href="https://baike.baidu.com/item/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/5618867?fr=aladdin">敏捷开发</a></p></blockquote><h3 id="实现回合制对战基本框架"><a href="#实现回合制对战基本框架" class="headerlink" title="实现回合制对战基本框架"></a>实现回合制对战基本框架</h3><p>角色类Role定义角色的血量、攻击力以及相关方法。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> attack</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp = <span class="number">100</span>;</span><br><span class="line">        attack = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span>(<span class="params"><span class="built_in">int</span> _hp, <span class="built_in">int</span> _attack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp = _hp;</span><br><span class="line">        attack = _attack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BeHit</span>(<span class="params"><span class="built_in">int</span> cost_hp</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp -= cost_hp;</span><br><span class="line">        <span class="keyword">if</span> (hp &lt; <span class="number">0</span>) hp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的角色类，使用它只需要实例化即可。</p><pre><code>Role player = new Role();Role monster = new Role(200,10);</code></pre><p>而游戏主循环的设计更加简单，在Main函数中使用一个while循环即可。</p><pre><code>while (true)&#123;    monster.BeHit(player.attack);    Console.ForegroundColor = ConsoleColor.DarkGreen;    Console.WriteLine(&quot;【怪物】被攻击，目前生命：&#123;0&#125;&quot;,  monster.hp);    if (monster.hp &lt;= 0) break;    player.BeHit(monster.attack);    Console.ForegroundColor = ConsoleColor.Gray;    Console.WriteLine(&quot;【玩家】被攻击，失去&#123;0&#125;点生命，目前生命：&#123;0&#125;&quot;, player.hp);    if (player.hp &lt;= 0) break;&#125;if (player.hp &gt; 0)&#123;    Console.WriteLine(&quot;玩家胜利&quot;);&#125;else&#123;    Console.WriteLine(&quot;怪物胜利&quot;);&#125;</code></pre><p>一个简单的回合制游戏循环完成了。输出方面使用的是命令行输出，通过更改<strong>Console.ForegroundColor</strong>来更改输出文字颜色。在最后判断玩家和怪物的血量从而输出哪边胜利。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-3</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-3/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>让自己的List支持泛型<T>。</p><!---more---><h2 id="自己实现List-泛型扩展"><a href="#自己实现List-泛型扩展" class="headerlink" title="自己实现List - 泛型扩展"></a>自己实现List - 泛型扩展</h2><p>上一节使用设计的MyList类使用的数据类型全部为int型，要想兼容所有类型，需要用到泛型这个概念。</p><blockquote><p>泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。</p></blockquote><p>在这部分改写中，需要在类名后添加尖括号，声明泛型：</p><pre><code>class MyList&lt;T&gt;&#123; /...</code></pre><p>我们还要在之前用到int类型参数的地方修改，例如Add()方法：</p><pre><code>public void Add(T n)    &#123;   /...</code></pre><p>在使用中，声明MyList类型需要附加对应的泛型参数：</p><pre><code>MyList&lt;int&gt; list = new MyList&lt;int&gt;();</code></pre><p>注意：这里只是简单使用泛型进行改写，实际上泛型更加复杂。例如我们可以对T进行约束，使其只支持对应类型，其余类型不能够使用。</p><p>扩展：下标重写</p><p>要进行例如List[index]的引用使用，需要在MyList中进行下标重写。</p><pre><code>public T this[int index]    &#123;        get        &#123;            if (index &lt; 0 || index &gt; -len)            &#123;                return default(T);            &#125;            return mem[index];        &#125;        set        &#123;            if (index &lt; 0 || index &gt;= len)            &#123;                return;            &#125;            mem[index] = value;        &#125;    &#125;</code></pre><p>这里使用get与set方法的原因，是将这种List[index]设定为一个属性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-2</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-2/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这期我们自己实现List的基本功能。</p><!---more---><h2 id="自己实现List-基本功能"><a href="#自己实现List-基本功能" class="headerlink" title="自己实现List - 基本功能"></a>自己实现List - 基本功能</h2><p>使用数组来自己实现List功能。List有以下几个主要功能：</p><ol><li>初始化</li><li>Add - 添加元素</li><li>RemoveAt - 删除对应位置元素</li><li>Get - 获得对应位置元素</li><li>Count - 元素总数</li></ol><p>以Add为例，在添加一个元素之前要临时构建一个新数组，将原数组的数据存入，并将添加的元素加在新数组的最后。</p><pre><code>public void Add(int n)    &#123;        if (len &gt;= mem.Length)        &#123;            int[] mem_new = new int[mem.Length * 2];            mem.CopyTo(mem_new, 0);            mem = mem_new;        &#125;        mem[len] = n;        len++;    &#125;</code></pre><p>而Remove等方法需要注意下标越界等问题，在进入方法后先做相关判断。</p><pre><code>if(len&lt;0 || len &lt;= index)        &#123;            Console.WriteLine(&quot;RemoveAt 下标越界&#123;0&#125; &#123;1&#125;&quot;, len, index);            return;        &#125;</code></pre><p>Count与Get即为简单的获取长度和对应元素，在这里不详细展开。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础系列笔记-1</title>
      <link href="2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-1/"/>
      <url>2018/10/04/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/CSharp%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个优秀的Unity3D开发者一定要掌握的C#基础。</p><!---more---><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这里记录皮皮关游戏的《游戏编程教程 真·C#基础》系列教程视频的相关笔记。这篇笔记中大多数内容为特定思路与方法的记录，少部分为个人的思考与扩展。</p><p>可以到以下网址观看皮皮关游戏的教程系列视频：</p><ul><li><a href="https://space.bilibili.com/38043731/#/video">皮皮关的个人空间</a></li><li><a href="https://www.bilibili.com/video/av18638861">【游戏编程教程】真·C#基础（1）【前期总结】</a></li></ul><p>同时推荐另一个up主<a href="https://space.bilibili.com/211153830/#/">傅老师MrFu</a>，他是一位台湾的老师，讲过Unity3D、blender以及OpenGL相关课程。在这里推荐他的Unity3D黑魂系列教程：</p><ul><li><a href="https://www.bilibili.com/video/av21513489">DarkSouls複刻經典教程#第一季</a></li><li><a href="https://www.bilibili.com/video/av23518888">DarkSouls複刻經典教程#第二季</a></li><li><a href="https://www.bilibili.com/video/av22661687">DarkSouls關卡場景設計教程#第一季</a></li></ul><p>接下来会根据学习进度进行这系列笔记的更新。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C# </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
